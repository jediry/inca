/*
 * File: operator-bases
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      The OperatorBase template class provides default implementations of
 *      most of the functions in the Raster interface, making the definition
 *      of a Raster-conforming operator very easy.
 *
 *      The UnaryOperator and BinaryOperator template classes further simplify
 *      the creation of operators taking one and two Raster arguments,
 *      respectively. In each case, the number of arguments that are required
 *      to be Rasters may be specified as a template parameter, and attempting
 *      to instantiate the operator with less than the requisite number of
 *      arguments results in a compile-time assertion.
 *
 * Using this file:
 *      Since much of the code for defining operators based on these classes
 *      is trivial and repetitive, this file provides a set of macros that
 *      can do most of the work in the simple case. This file does not have
 *      the normal #ifndef...#endif multi-include protection over the whole
 *      file, but rather only over the class definitions. If the macro
 *      UNDEFINE_INCA_RASTER_OPERATOR_MACROS is defined when this file is
 *      included then, instead of defining the macros, it #undef's them (and
 *      UNDEFINE_INCA_RASTER_OPERATOR_MACROS as well).
 */

/*---------------------------------------------------------------------------*/
#ifndef UNDEFINE_INCA_RASTER_OPERATOR_MACROS            /* Create the macros */
/*---------------------------------------------------------------------------*/

// Import metaprogramming tools and simplifying macros
#include <inca/util/template-metaprogramming-macros.hpp>

// These macros create a set of three Raster-specific overloads for a C++
// operator or function. The various versions are governed by mutually
// exclusive SFINAE conditions. The first (and second) overloads will be used
// when the LHS (RHS) operand is a Raster and the RHS (LHS) operand is a
// plain-old-data type, respectively. In these cases, the POD operand needs to
// be passed by value in order for overload-resolution to select that overload.
// The third overload is used when neither operand is a POD, and at least one
// is a Raster, and passes both operands by reference.
//
// The unary version needs only one version, since its argument must be a
// raster.
#define BINARY_FUNCTION_OVERLOAD(FUNC, CLASS)                               \
    template <typename R1, typename R2>                                     \
    ENABLE_IF_T( AND2(is_raster<R1>, boost::is_pod<R2>),                    \
                 CLASS<R1 COMMA R2> )                                       \
        FUNC(R1 &r1, R2 r2) { return CLASS<R1, R2>(r1, r2); }               \
    template <typename R1, typename R2>                                     \
    ENABLE_IF_T( AND2(is_raster<R2>, boost::is_pod<R1>),                    \
                 CLASS<R1 COMMA R2> )                                       \
        FUNC(R1 r1, R2 &r2) { return CLASS<R1, R2>(r1, r2); }               \
    template <typename R1, typename R2>                                     \
    ENABLE_IF_T( OR2( AND2(is_raster<R1>, NOT(boost::is_pod<R2>)),          \
                      AND2(is_raster<R2>, NOT(boost::is_pod<R1>))),         \
                 CLASS<R1 COMMA R2> )                                       \
        FUNC(R1 &r1, R2 &r2) { return CLASS<R1, R2>(r1, r2); }

#define UNARY_FUNCTION_OVERLOAD(FUNC, CLASS)                                \
    template <typename R1>                                                  \
    ENABLE_IF_T( is_raster<R1>, CLASS<R1> )                                 \
        FUNC(R1 &r1) { return CLASS<R1>(r1); }


// This macro creates a set of two Raster-specific overloads for one of the
// standard C++ "computed assignment" operators (e.g., +=, |=). The two
// versions are the same as created by the previous macro, except that the
// LHS argument must always be a Raster (thus ruling out the (POD op R) case),
// and that the Raster is required to be writable. The operator is implemented
// in terms of the corresponding "normal" operator (e.g. +, |), which must be
// a valid operator for the types involved.
#define COMPUTED_ASSIGNMENT_OPERATOR(OP)                                    \
    template <typename R1, typename R2>                                     \
    ENABLE_IF_T( AND2(is_writable_raster<R1>, boost::is_pod<R2>), R1 &)     \
    operator OP##=(R1 &r1, R2 r2) {                                         \
        return (r1 = r1 OP r2);                                             \
    }                                                                       \
    template <typename R1, typename R2>                                     \
    ENABLE_IF_T( AND2(is_writable_raster<R1>, NOT(boost::is_pod<R2>)), R1 &)\
    operator OP##=(R1 &r1, const R2 &r2) {                                  \
        return (r1 = r1 OP r2);                                             \
    }


// XXX right now this is hackish w/r to the return type
// This macro creates a Raster operator class inheriting BinaryRaster that
// simply evaluates one of the standard binary C++ operators with its two
// operands. It also calls BINARY_OPERATOR_OVERLOAD to create the appropriate
// operator overloads.
#define LAMBDA_RETURN_TYPE                                                  \
typename boost::lambda::return_type_2<                                      \
            typename boost::lambda::arithmetic_action<                      \
                        boost::lambda::plus_action                          \
                     >,                                                     \
            typename element_type<R1>::type,                                \
            typename element_type<R2>::type                                 \
         >::type

#define BINARY_OPERATOR(OP, CLASS)                                          \
    template <typename R1, typename R2>                                     \
    class CLASS                                                             \
        : public BinaryRasterOperator<R1, R2, LAMBDA_RETURN_TYPE>  {        \
    public:                                                                 \
        typedef LAMBDA_RETURN_TYPE                          ReturnType;     \
        typedef BinaryRasterOperator<R1, R2, ReturnType>    Superclass;     \
        typedef typename Superclass::ElementType            ElementType;    \
        typedef CLASS<R1, R2>                               OperatorType;   \
                                                                            \
        /* Constructor */                                                   \
        CLASS(R1 & r1, R2 & r2) : Superclass(r1, r2) { }                    \
                                                                            \
        /* Evaluator function */                                            \
        template <class IndexList>                                          \
        ElementType operator()(const IndexList &indices) const {            \
            return first(indices) OP second(indices);                       \
        }                                                                   \
    };                                                                      \
    /* Create an overloaded C++ operator corresponding to this class */     \
    BINARY_FUNCTION_OVERLOAD(operator OP, CLASS)


// XXX right now this is hackish w/r to the return type
// This macro creates a Raster function class inheriting BinaryRasterOperator
// that simply evaluates a binary function with its two operands. It also calls
// BINARY_FUNCTION_OVERLOAD to create the appropriate generator functions.
#define BINARY_FUNCTION(FUNC, CLASS)                                        \
    template <typename R1, typename R2>                                     \
    class CLASS : public BinaryRasterOperator<R1, R2, LAMBDA_RETURN_TYPE> { \
    public:                                                                 \
        typedef LAMBDA_RETURN_TYPE                          ReturnType;     \
        typedef BinaryRasterOperator<R1, R2, ReturnType>    Superclass;     \
        typedef typename Superclass::ElementType            ElementType;    \
        typedef CLASS<R1, R2>                               OperatorType;   \
                                                                            \
        /* Constructor */                                                   \
        CLASS(R1 & r1, R2 & r2) : Superclass(r1, r2) { }                    \
                                                                            \
        /* Evaluator function */                                            \
        template <class IndexList>                                          \
        ElementType operator()(const IndexList &indices) const {            \
            return FUNC(first(indices), second(indices));                   \
        }                                                                   \
    };                                                                      \
    /* Create an overloaded C++ function corresponding to this class */     \
    BINARY_FUNCTION_OVERLOAD(FUNC, CLASS)


// XXX right now this is hackish w/r to the return type
// This macro creates a Raster function class inheriting UnaryRasterOperator
// that simply evaluates a unary function with its operand. It also calls
// UNARY_FUNCTION_OVERLOAD to create the appropriate generator functions.
#define UNARY_FUNCTION(FUNC, CLASS)                                         \
    template <typename R1>                                                  \
    class CLASS : public UnaryRasterOperator<R1, typename R1::ElementType> {\
    public:                                                                 \
        typedef typename R1::ElementType                    ReturnType;     \
        typedef UnaryRasterOperator<R1, ReturnType>         Superclass;     \
        typedef typename Superclass::ElementType            ElementType;    \
        typedef CLASS<R1>                                   OperatorType;   \
                                                                            \
        /* Constructor */                                                   \
        CLASS(R1 & r1) : Superclass(r1) { }                                 \
                                                                            \
        /* Evaluator function */                                            \
        template <class IndexList>                                          \
        ElementType operator()(const IndexList &indices) const {            \
            return FUNC(first(indices));                                    \
        }                                                                   \
    };                                                                      \
    /* Create an overloaded C++ function corresponding to this class */     \
    UNARY_FUNCTION_OVERLOAD(FUNC, CLASS)


/*---------------------------------------------------------------------------*
 | Beginning of multi-include-protected portion
 *---------------------------------------------------------------------------*/
#ifndef INCA_RASTER_OPERATOR_BASES
#define INCA_RASTER_OPERATOR_BASES

// Import system configuration
#include <inca/inca-common.h>

// This is part of the Inca raster processing library
namespace inca {
    namespace raster {
        // Forward declarations
        template <SizeType dim>     class OperatorBase;
        template <typename T,
                  SizeType dim,
                  typename Enabled> class RasterArgumentHolder;
        template <typename T1,
                  typename ReturnT> class UnaryRasterOperator;
        template <typename T1,
                  typename T2,
                  typename ReturnT> class BinaryRasterOperator;
    };
};

// Import concept tag definitions
#include "../concepts"

// Import boost::lambda type conversions for color (HACK!)
#include "hacked_in_lambda"

/*

// Import iterator definition
#include <inca/util/iterators/MultiDimensionalIterator>

#define MULTI_DIM_ITERATOR_DEFINITIONS                                                                      \
    typedef MultiDimensionalIterator<OperatorType, typename ElementType, false>       Iterator;             \
    typedef MultiDimensionalIterator<OperatorType, typename ElementType const, false> ConstIterator;        \
    typedef MultiDimensionalIterator<OperatorType, typename ElementType, true>        ReverseIterator;      \
    typedef MultiDimensionalIterator<OperatorType, typename ElementType const, true>  ConstReverseIterator; \
                                                                                                            \
         Iterator begin()        { return Iterator(*this, bases()); }                                       \
    ConstIterator begin() const  { return ConstIterator(*this, bases()); }                                  \
         Iterator end()          { return Iterator(*this); }                                                \
    ConstIterator end() const    { return ConstIterator(*this); }                                           \
         ReverseIterator reverseBegin()       { return ReverseIterator(*this, extents()); }                 \
    ConstReverseIterator reverseBegin() const { return ConstReverseIterator(*this, extents()); }            \
         ReverseIterator reverseEnd()         { return ReverseIterator(*this); }                            \
    ConstReverseIterator reverseEnd() const   { return ConstReverseIterator(*this); }
*/

// Base class implementing the size/index accessor functions
template <inca::SizeType dim>
class inca::raster::OperatorBase {
public:
    // How many dimensions are we working in?
    static const SizeType dimensionality = dim;

    // Size/index type definitions
//    typedef inca::SizeType                          SizeType;
//    typedef inca::IndexType                         IndexType;
    typedef inca::Array<SizeType, dimensionality>   SizeArray;
    typedef inca::Array<IndexType, dimensionality>  IndexArray;

    // Access to calculated size and valid index ranges
    SizeType size() const               { return _size; }
    SizeType size(IndexType d) const    { return _sizes[d]; }
    const SizeArray & sizes() const     { return _sizes; }
    IndexType base(IndexType d) const   { return _bases[d]; }
    const IndexArray & bases() const    { return _bases; }
    IndexType extent(IndexType d) const { return _extents[d]; }
    const IndexArray & extents() const  { return _extents; }

protected:
    SizeType    _size;      // The total number of elements
    SizeArray   _sizes;     // Number of elements along each dimension
    IndexArray  _bases,     // Starting index along each dimension
                _extents;   // Ending index along each dimension

    // Prune the valid region (ensure there are no negative sizes) and
    // calculate the size of the region. The values of _bases and _extents
    // must have already been set.
    void validateRegion() {
        _size = 1;
        for (IndexType d = 0; d < dimensionality; ++d) {
            DifferenceType diff = extent(d) - base(d) + 1;
            if (diff < 0) {     // Clamp to a minimal size of 0
                diff = 0;
                _extents[d] = _bases[d] - 1;
            }
            _sizes[d] = diff;
            _size *= diff;
        }
        if (_size == 0)
            cerr << "Uh oh...zero-sized Raster operator" << endl;
    }
};


#if 0
namespace inca {
    namespace raster {
        // Forward declarations for template specializations
        template <typename T, inca::SizeType dim>
        class RasterArgumentHolder<T, dim,
                            ENABLE_IF( AND2(is_raster<T>,
                                        NOT(is_in_memory_raster<T>)))>;


        template <typename T, inca::SizeType dim>
        class RasterArgumentHolder<T, dim,
                            ENABLE_IF( AND2(is_raster<T>,
                                            is_in_memory_raster<T>))>;
    };
};
#endif

// Unspecialized argument holder for any non-raster argument
template <typename T, inca::SizeType dim, typename Enabled = void>
class inca::raster::RasterArgumentHolder {
public:
    // Contained type definitions
    typedef T                       ArgumentType;   // Base argument type
    typedef T                       ElementType;    // Base element type
    typedef ArgumentType            HeldType;       // How we hold it
    typedef ElementType             ReturnType;     // How we return it
    typedef ElementType const       ConstReturnType;

    // Size/index type definitions
    typedef typename OperatorBase<dim>::SizeArray   SizeArray;
    typedef typename OperatorBase<dim>::IndexArray  IndexArray;

    // Constructor
    RasterArgumentHolder(const ArgumentType & arg)
        : _argument(arg), _zeroSizes(0), _zeroBases(0), _minusOneExtents(-1) { }

    // Argument accessor
    const HeldType & argument() const { return _argument; }

    // Element accessor
    template <class IndexList>
    ConstReturnType operator()(const IndexList & indices) const {
        return _argument;               // Just return the argument
    }

    // Size/index access (just return dummy values)
    SizeType size() const               { return 0; }
    SizeType size(IndexType d) const    { return 0; }
    const SizeArray & sizes() const     { return _zeroSizes; }
    IndexType base(IndexType d) const   { return 0; }
    const IndexArray & bases() const    { return _zeroBases; }
    IndexType extent(IndexType d) const { return -1; }
    const IndexArray & extents() const  { return _minusOneExtents; }

protected:
    SizeArray _zeroSizes;       // Dummy array arguments
    IndexArray _zeroBases, _minusOneExtents;

    HeldType _argument;     // The argument we're holding
};


// Specialization of argument holder for holding a lightweight raster argument
// (i.e., a raster that does not actually occupy memory proportional to its
// size). These can be copied freely.
template <typename T, inca::SizeType dim>
class inca::raster::RasterArgumentHolder<T, dim,
                    ENABLE_IF( AND2(inca::raster::is_raster<T>,
                                NOT(inca::raster::is_in_memory_raster<T>)))> {
public:
    // Contained type definitions
    typedef T                       ArgumentType;   // Base argument type
    typedef typename T::ElementType ElementType;    // Base element type
    typedef ArgumentType            HeldType;       // How we hold it
    typedef ElementType             ReturnType;     // How we return it
    typedef ElementType const       ConstReturnType;

    // Size/index type definitions
    typedef typename OperatorBase<dim>::SizeArray   SizeArray;
    typedef typename OperatorBase<dim>::IndexArray  IndexArray;

    // Constructor
    RasterArgumentHolder(const ArgumentType & arg) : _argument(arg) { }

    // Argument accessor
    const HeldType & argument() const { return _argument; }

    // Element accessor
    template <class IndexList>
    ConstReturnType operator()(const IndexList & indices) const {
        return _argument(indices);      // Index into the raster
    }

    // Size/index access (pass thru to the contained Raster)
    SizeType size() const               { return argument().size(); }
    SizeType size(IndexType d) const    { return argument().size(d); }
    const SizeArray & sizes() const     { return argument().sizes(); }
    IndexType base(IndexType d) const   { return argument().base(d); }
    const IndexArray & bases() const    { return argument().bases(); }
    IndexType extent(IndexType d) const { return argument().extent(d); }
    const IndexArray & extents() const  { return argument().extents(); }

protected:
    HeldType _argument;     // The argument we're holding
};


// Specialization of argument holder for holding a heavyweight raster argument
// (i.e., a raster that occupies memory in proportion to its size). These
// must be held by reference to avoid copies.
template <typename T, inca::SizeType dim>
class inca::raster::RasterArgumentHolder<T, dim,
                    ENABLE_IF( AND2(inca::raster::is_raster<T>,
                                    inca::raster::is_in_memory_raster<T>))> {
public:
    // Contained type definitions
    typedef T                       ArgumentType;   // Base argument type
    typedef typename T::ElementType ElementType;    // Base element type
    typedef ArgumentType &          HeldType;       // How we hold it
    typedef ElementType &           ReturnType;     // How we return it
    typedef ElementType const &     ConstReturnType;

    // Size/index type definitions
//    typedef typename OperatorBase<dim>::SizeType    SizeType;
//    typedef typename OperatorBase<dim>::IndexType   IndexType;
    typedef typename OperatorBase<dim>::SizeArray   SizeArray;
    typedef typename OperatorBase<dim>::IndexArray  IndexArray;

    // Constructor
    RasterArgumentHolder(ArgumentType & arg) : _argument(arg) { }

    // Copy constructor
    RasterArgumentHolder(const RasterArgumentHolder<T, dim, void> &a)
        : _argument(a._argument) { }

    // Argument accessor
    const ArgumentType & argument() const { return _argument; }

    // Element accessor
    template <class IndexList>
    ConstReturnType operator()(const IndexList & indices) const {
        return _argument(indices);      // Index into the raster
    }
    template <class IndexList>
    ReturnType operator()(const IndexList & indices) {
        return _argument(indices);      // Index into the raster
    }

    // Size/index access (pass thru to the contained Raster)
    SizeType size() const               { return argument().size(); }
    SizeType size(IndexType d) const    { return argument().size(d); }
    const SizeArray & sizes() const     { return argument().sizes(); }
    IndexType base(IndexType d) const   { return argument().base(d); }
    const IndexArray & bases() const    { return argument().bases(); }
    IndexType extent(IndexType d) const { return argument().extent(d); }
    const IndexArray & extents() const  { return argument().extents(); }

protected:
    HeldType _argument;     // The argument we're holding
};


// Base class implementing access to both arguments of a binary operator
template <class T1, class RT>
class inca::raster::UnaryRasterOperator
        : public OperatorBase<T1::dimensionality>,
          public UnaryRasterOperatorTag,
          // This is arbitrary-size only if its argument is arbitrary-size
          public IF ( is_arbitrary_size_raster<T1>,
                      ArbitrarySizeRasterTag,
                      FixedSizeRasterTag )::type {
public:
    // Types imported from OperatorBase class
//    typedef typename OperatorBase<dimensionality>::SizeType     SizeType;
//    typedef typename OperatorBase<dimensionality>::IndexType    IndexType;
    typedef typename OperatorBase<dimensionality>::SizeArray    SizeArray;
    typedef typename OperatorBase<dimensionality>::IndexArray   IndexArray;

    // Argument holder types
    typedef RasterArgumentHolder<T1, dimensionality>    FirstArgumentHolder;

    // Operand types
    typedef typename FirstArgumentHolder::ArgumentType  FirstArgumentType;

    // Individual element types
    typedef typename FirstArgumentHolder::ElementType   FirstElementType;

    // How we return things
    typedef typename FirstArgumentHolder::ReturnType        FirstReturnType;
    typedef typename FirstArgumentHolder::ConstReturnType   FirstConstReturnType;

    // What it returns
    typedef RT                                          ElementType;

    // What type am I?
    typedef UnaryRasterOperator<T1, RT>                 OperatorType;

    // How many of our arguments are Rasters?
    static const SizeType rasterCount = is_raster<T1>::value;

    BOOST_STATIC_ASSERT(rasterCount > 0);

    // Constructor
    UnaryRasterOperator(FirstArgumentType & f) : _first(f) {
        _bases = _first.bases();
        _extents = _first.extents();
        validateRegion();
    }

    // Argument accessors
    template <class IndexList>
    FirstConstReturnType first(const IndexList & indices) const {
        return _first(indices);
    }
    template <class IndexList>
    FirstReturnType first(const IndexList & indices) {
        return _first(indices);
    }

protected:
    FirstArgumentHolder  _first;
};


// Base class implementing access to both arguments of a binary operator
template <class T1, class T2, class ReturnT>
class inca::raster::BinaryRasterOperator
        : public OperatorBase< IF ( is_raster<T1>,
                                    raster_dimensionality<T1>,
                                    raster_dimensionality<T2> )::type::value >,
          public BinaryRasterOperatorTag,
          // This is arbitrary-size only if both arguments are either
          // arbitrary-size or not a raster.
          public IF ( AND2(
                        OR2(NOT(is_raster<T1>), is_arbitrary_size_raster<T1>),
                        OR2(NOT(is_raster<T2>), is_arbitrary_size_raster<T2>)),
                      ArbitrarySizeRasterTag,
                      FixedSizeRasterTag )::type {
public:
    // Types imported from OperatorBase class
//    typedef typename OperatorBase<dimensionality>::SizeType     SizeType;
//    typedef typename OperatorBase<dimensionality>::IndexType    IndexType;
    typedef typename OperatorBase<dimensionality>::SizeArray    SizeArray;
    typedef typename OperatorBase<dimensionality>::IndexArray   IndexArray;

    // Argument holder types
    typedef RasterArgumentHolder<T1, dimensionality>    FirstArgumentHolder;
    typedef RasterArgumentHolder<T2, dimensionality>    SecondArgumentHolder;

    // Operand types
    typedef typename FirstArgumentHolder::ArgumentType  FirstArgumentType;
    typedef typename SecondArgumentHolder::ArgumentType SecondArgumentType;

    // Individual element types
    typedef typename FirstArgumentHolder::ElementType   FirstElementType;
    typedef typename SecondArgumentHolder::ElementType  SecondElementType;

    // How we return things
    typedef typename FirstArgumentHolder::ReturnType        FirstReturnType;
    typedef typename FirstArgumentHolder::ConstReturnType   FirstConstReturnType;
    typedef typename SecondArgumentHolder::ReturnType       SecondReturnType;
    typedef typename SecondArgumentHolder::ConstReturnType  SecondConstReturnType;

    // What it returns (using the boost::lambda type-deduction mechanism)
    typedef ReturnT                                     ElementType;

    // What type am I?
    typedef BinaryRasterOperator<T1, T2, ReturnT>       OperatorType;

    // How many of our arguments are Rasters?
    static const SizeType rasterCount = is_raster<T1>::value
                                      + is_raster<T2>::value;

    BOOST_STATIC_ASSERT(rasterCount > 0);

    // Which of them want a say in our size?
    static const bool firstArgumentAffectsRegion =
        OR2(is_fixed_size_raster<T1> , is_resizable_raster<T1>)::value;
    static const bool secondArgumentAffectsRegion =
        OR2(is_fixed_size_raster<T2> , is_resizable_raster<T2>)::value;


    // Constructor
    BinaryRasterOperator(FirstArgumentType & f,
                         SecondArgumentType & s,
                         bool unionRegions = false)
            : _first(f), _second(s) {

        // Get references to each operand's index bases/extents
        const IndexArray & firstBases  = _first.bases();
        const IndexArray & secondBases = _second.bases();
        const IndexArray & firstExtents  = _first.extents();
        const IndexArray & secondExtents = _second.extents();

        // Calculate the valid region resulting from evaluating this operator
        if (firstArgumentAffectsRegion && secondArgumentAffectsRegion) {
            if (unionRegions)
                // Calculate the union
                for (IndexType d = 0; d < dimensionality; ++d) {
                    _bases[d] = math::min(firstBases[d], secondBases[d]);
                    _extents[d] = math::max(firstExtents[d], secondExtents[d]);
                }
            else
                // Calculate the intersection
                for (IndexType d = 0; d < dimensionality; ++d) {
                    _bases[d] = math::max(firstBases[d], secondBases[d]);
                    _extents[d] = math::min(firstExtents[d], secondExtents[d]);
                }
        } else if (firstArgumentAffectsRegion) {
            // Copy the region from the first argument
            _bases = firstBases;
            _extents = firstExtents;
        } else if (secondArgumentAffectsRegion) {
            // Copy the region from the second argument
            _bases = secondBases;
            _extents = secondExtents;
        } else {
            // Default to an empty region
            _bases = IndexArray(0);
            _extents = IndexArray(-1);
        }
        
        // Prune the region we defined and determine its size
        validateRegion();
    }

    // Argument accessors
    template <class IndexList>
    FirstConstReturnType first(const IndexList & indices) const {
        return _first(indices);
    }
    template <class IndexList>
    FirstReturnType first(const IndexList & indices) {
        return _first(indices);
    }
    template <class IndexList>
    SecondConstReturnType second(const IndexList & indices) const {
        return _second(indices);
    }
    template <class IndexList>
    SecondReturnType second(const IndexList & indices) {
        return _second(indices);
    }

protected:
    FirstArgumentHolder  _first;
    SecondArgumentHolder _second;
};

#endif

/*---------------------------------------------------------------------------*/
#else   /* UNDEFINE_INCA_RASTER_OPERATOR_MACROS was defined, so remove them  */
/*---------------------------------------------------------------------------*/

#undef BINARY_OPERATOR
#undef BINARY_OPERATOR_OVERLOAD
#undef COMPUTED_ASSIGNMENT_OPERATOR

// Since we included these macros, we have to clean them up too
#define UNDEFINE_INCA_METAPROGRAMMING_MACROS
#include <inca/util/template-metaprogramming-macros.hpp>

// Finally, make sure we can re-enable these macros later
#undef UNDEFINE_INCA_RASTER_OPERATOR_MACROS

/*---------------------------------------------------------------------------*/
#endif                                                 /* All done...go home */
/*---------------------------------------------------------------------------*/
