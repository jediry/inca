/*
 * File: DFT
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file implements a discrete Fourier transform (DFT) of the input
 *      raster. Unlike many of the operators in the Inca raster library, this
 *      operator evaluates its input over the entire domain when it is first
 *      accessed and simply returns elements from the transform when accessed
 *      subsequently.
 *
 * Implementation:
 *      Note that because it internally caches the transformed elements, it
 *      implements the InMemoryRasterConcept. Furthermore, because the DFT
 *      requires a known, finite amount of input data, the input raster cannot
 *      implement the ArbitrarySizedRasterConcept.
 *
 * XXX This needs change tracking to know when to regenerate the transform.
 * This could also do MUCH better as far as optimization.
 */

#ifndef INCA_RASTER_OPERATORS_DFT
#define INCA_RASTER_OPERATORS_DFT


// Import operator base classes and macros
#include "operator-bases"
#include "../MultiArrayRaster"

// Import complex number definition
#include <complex>

// This is part of the Inca raster processing library
namespace inca {
    namespace raster {
        // General form (less efficient, since it has to copy)
        template <typename R1, typename R2>
        void calculateDFT(R1 & dest, const R2 & r2);
        template <typename R1, typename R2>
        void calculateInverseDFT(R1 & dest, const R2 & r2);


        // DFT Specializations for float, double and long double
        // (implemented by third-party FFT library)
        template <>
        void calculateDFT(MultiArrayRaster< std::complex<float>, 2> & dest,
                          const MultiArrayRaster< float, 2 > & src);
        template <>
        void calculateDFT(MultiArrayRaster< std::complex<double>, 2> & dest,
                          const MultiArrayRaster< double, 2 > & src);
        template <>
        void calculateDFT(MultiArrayRaster< std::complex<long double>, 2> & dest,
                          const MultiArrayRaster< long double, 2 > & src);

        // Inverse DFT Specializations for float, double and long double
        // (implemented by third-party FFT library)
        template <>
        void calculateInverseDFT(MultiArrayRaster< float, 2> & dest,
                           const MultiArrayRaster< std::complex<float>, 2 > & src);
        template <>
        void calculateInverseDFT(MultiArrayRaster< double, 2> & dest,
                           const MultiArrayRaster< std::complex<double>, 2 > & src);
        template <>
        void calculateInverseDFT(MultiArrayRaster< long double, 2> & dest,
                           const MultiArrayRaster< std::complex<long double>, 2 > & src);

        // Time/space domain => frequency domain transformation operator
        template <typename R1>
        class DFTRasterOperator
                    : public UnaryRasterOperator<R1, std::complex<typename R1::ElementType> >,
                      public InMemoryRasterTag {
        public:
            typedef UnaryRasterOperator<R1, std::complex<typename R1::ElementType> > Superclass;
            typedef DFTRasterOperator<R1>               OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef typename Superclass::IndexArray     IndexArray;
            
            // Constructor
            DFTRasterOperator(R1 & r) : Superclass(r) {
                MultiArrayRaster<typename R1::ElementType, dimensionality> input(r);
                calculateDFT(dft, input);
                this->_bases = dft.bases();
                this->_extents = dft.extents();
                validateRegion();
            }

            // Evaluator function
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                return dft(indices);
            }

        protected:
            // The DFT coefficients
            MultiArrayRaster<ElementType, R1::dimensionality> dft;
        };

        // Frequency domain => time/space domain transformation operator
        template <typename R1>
        class InverseDFTRasterOperator
                    : public UnaryRasterOperator<R1, typename R1::ElementType::value_type >,
                      public InMemoryRasterTag {
        public:
            typedef UnaryRasterOperator<R1, typename R1::ElementType::value_type > Superclass;
            typedef InverseDFTRasterOperator<R1>        OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef typename Superclass::IndexArray     IndexArray;
            
            // Constructor
            InverseDFTRasterOperator(R1 & r) : Superclass(r) {
                MultiArrayRaster<typename R1::ElementType, dimensionality> input(r);
                calculateInverseDFT(idft, input);
                this->_bases = idft.bases();
                this->_extents = idft.extents();
                validateRegion();
            }

            // Evaluator function
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                return idft(indices);
            }

        protected:
            // The iDFT coefficients
            MultiArrayRaster<ElementType, R1::dimensionality> idft;
        };

        // Expand non-redundant representation of DFT to be symmetrical
        template <typename R1>
        class ExpandDFTRasterOperator
                    : public UnaryRasterOperator<R1, typename R1::ElementType> {
        public:
            typedef UnaryRasterOperator<R1, typename R1::ElementType> Superclass;
            typedef ExpandDFTRasterOperator<R1>        OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef typename Superclass::IndexArray     IndexArray;
            
            // Constructor
            ExpandDFTRasterOperator(R1 & r, bool _DCInCenter)
                    : Superclass(r), DCInCenter(_DCInCenter) {
#if 0
                // Figure out how big we're supposed to be
                
                // Determine center elements
                centerLeft((this->size(0) - 1) / 2,
                           (this->size(1) - 1) / 2);
                centerRight(centerLeft[0] + !(r.size(0) % 2),    // Up one?
                       center[1] + !(r.size(1) % 2));
#endif
            }

            // Evaluator function
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                return idft(indices);
            }

        protected:
            // Whether we want the DC component at the center or the corner
            bool DCInCenter;
            
            // Calculation of our "center" points (may be identical)
            IndexArray centerLeft, centerRight;
        };

        // Factory function for calculating the DFT and its inverse
        template <typename R1>
        DFTRasterOperator<R1> DFT(R1 &r) {
            return DFTRasterOperator<R1>(r);
        }
        template <typename R1>
        InverseDFTRasterOperator<R1> iDFT(R1 &r) {
            return InverseDFTRasterOperator<R1>(r);
        }

        // Factory function
        template <typename R1>
        ExpandDFTRasterOperator<R1> expand(R1 &r, bool DCInCenter = false) {
            return ExpandDFTRasterOperator<R1>(r, DCInCenter);
        }
    };
};

// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_RASTER_OPERATOR_MACROS
#include "operator-bases"

#endif

