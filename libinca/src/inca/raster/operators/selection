/*
 * File: selection
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file implements a rectangular selection of a raster that is
 *      itself a raster. This is useful for reading/writing just a subregion
 *      of an image. The index range of the selected region can either stay
 *      the same as those of the selected cells, or it can be translated to
 *      the origin (such that whatever region you select, it still starts from
 *      (0,0,...)).
 */

#ifndef INCA_RASTER_OPERATORS_SELECTION
#define INCA_RASTER_OPERATORS_SELECTION


// Import operator base classes and macros
#include "operator-bases"

// This is part of the Inca raster processing library
namespace inca {
    namespace raster {
        // Selection operator (general form, not writable)
        template <typename R1, class Enabled = void>
        class SelectRegionRasterOperator
                    : public UnaryRasterOperator<R1, typename R1::ElementType> {
        public:
            typedef UnaryRasterOperator<R1, typename R1::ElementType> Superclass;
            typedef SelectRegionRasterOperator<R1, Enabled>     OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef typename Superclass::IndexArray     IndexArray;
            
            // Constructor
            template <class IndexList>
            SelectRegionRasterOperator(R1 & r, const IndexList & i1,
                                               const IndexList & i2,
                                               bool relocateToOrigin = true)
                    : Superclass(r) {
                // Extract the max and min corners
                for (IndexType d = 0; d < dimensionality; ++d) {
                    _bases[d] = inca::math::min(i1[d], i2[d]);
                    _extents[d] = inca::math::max(i1[d], i2[d]);
                }

                // Clip that to the bounds of the underlying Raster
                for (IndexType d = 0; d < dimensionality; ++d) {
                    _bases[d] = inca::math::max(_bases[d], r.base(d));
                    _extents[d] = inca::math::min(_extents[d], r.extent(d));
                }

                // Tighten any negative sizes
                validateRegion();

                // If we need to relocate to the origin, do so
                if (relocateToOrigin) {
                    _relocation = _bases;
                    for (IndexType d = 0; d < dimensionality; ++d) {
                        _bases[d]   -= _relocation[d];
                        _extents[d] -= _relocation[d];
                    }
                } else
                    _relocation = IndexArray(0);
            }

            // Evaluator function
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                typename Superclass::IndexArray idx;
                for (IndexType d = 0; d < dimensionality; ++d)
                    idx[d] = indices[d] + _relocation[d];
                return first(idx);
            }

        protected:
            // How much to alter indices by
            IndexArray _relocation;
        };


        // Writable specialization (inherits from general form)
        template <typename R1>
        class SelectRegionRasterOperator<R1, ENABLE_IF(is_writable_raster<R1>) >
                : public SelectRegionRasterOperator<R1, int>,
                  public WritableRasterTag {
        public:
            typedef SelectRegionRasterOperator<R1, int> Superclass;
            typedef SelectRegionRasterOperator<R1>      OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef typename Superclass::IndexArray     IndexArray;

            // Constructor
            template <class IndexList>
            SelectRegionRasterOperator(R1 & r, const IndexList & i1,
                                               const IndexList & i2,
                                               bool relocateToOrigin = true)
                : SelectRegionRasterOperator<R1, int>
                    (r, i1, i2, relocateToOrigin) { }

            // Fill with a constant value (must be convertible to the ElementType)
            template <typename T>
            ENABLE_IF_T( NOT(is_raster<T>), OperatorType &)
            operator=(const T & t) {
                fill(*this, t);                 // Stick this into every slot
                return *this;                   // Return a reference
            }

            // Copy from another Raster object
            template <class R>
            ENABLE_IF_T(is_raster<R>, OperatorType &)
            operator=(const R &r) {
                copy(*this, r);                 // Copy all the elements
                return *this;                   // Return a reference
            }

            // Evaluator operators (return reference if non-const)
            template <class IndexList>
            ElementType & operator()(const IndexList &indices) {
                IndexArray idx;
                for (IndexType d = 0; d < dimensionality; ++d)
                    idx[d] = indices[d] + _relocation[d];
                return first(idx);
            }
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                return Superclass::operator()(indices);
            }
        };


        // Factory function
        template <typename R1, class IndexList>
        SelectRegionRasterOperator<R1> select(R1 &r, const IndexList &i1,
                                                     const IndexList &i2,
                                                     bool relocate = true) {
            return SelectRegionRasterOperator<R1>(r, i1, i2, relocate);
        }
    };
};

// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_RASTER_OPERATOR_MACROS
#include "operator-bases"

#endif

