/*
 * File: gradient
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file implements a gradient operator that calculates a forward
 *      finite difference gradient returned as a raster of inca::math::Vectors
 *      of the input type.
 */

#ifndef INCA_RASTER_OPERATORS_GRADIENT
#define INCA_RASTER_OPERATORS_GRADIENT


// Import operator base classes and macros
#include "operator-bases"

// Import the Vector class
#include <inca/math/linalg.hpp>

// This is part of the Inca raster processing library
namespace inca {
    namespace raster {

        // Gradient operator
        template <typename R1>
        class GradientRasterOperator
                    : public UnaryRasterOperator<R1, inca::math::Vector<typename R1::ElementType, dimensionality> > {
        public:
            typedef inca::math::Vector<typename R1::ElementType, dimensionality> Vector;
            typedef UnaryRasterOperator<R1, Vector> Superclass;
            typedef GradientRasterOperator<R1>     OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef Array<typename R1::ElementType, dimensionality> ScalarArray;
            
            // Constructor
            template <class ScalarList>
            GradientRasterOperator(R1 & r, const ScalarList & d)
                : Superclass(r), differentials(d) { }

            // Evaluator function
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                typename Superclass::IndexArray idx(indices);
                ElementType result;
                typename R1::ElementType center = first(idx);   // cell at idx                
                for (IndexType d = 0; d < dimensionality; ++d) {
                    idx[d]++;       // Point to adjacent element along this dim
                    result[d] = (first(idx) - center) / differentials[d];
                    idx[d]--;       // Return to center
                }
                return result;
            }

        protected:
            ScalarArray differentials;
        };


        // Factory function for uniform differentials (defaults to 1)
        template <typename R1, typename scalar>
        GradientRasterOperator<R1> gradient(R1 &r, const scalar & d) {
            return GradientRasterOperator<R1>(r, Array<scalar, R1::dimensionality>(d));
        }

        // Factory function specifying differentials for each dimension
        template <typename R1, class ScalarList>
        GradientRasterOperator<R1> gradient(R1 &r, const ScalarList & d) {
            return GradientRasterOperator<R1>(r, d);
        }

        // Vector angle operator
        template <typename R1>
        class VectorCanonicalAngleRasterOperator
                    : public UnaryRasterOperator<R1, typename R1::ElementType::scalar_t > {
        public:
            typedef UnaryRasterOperator<R1, typename R1::ElementType::scalar_t> Superclass;
            typedef VectorCanonicalAngleRasterOperator<R1>     OperatorType;
            typedef typename Superclass::ElementType    ElementType;
            typedef Array<typename R1::ElementType, dimensionality> ScalarArray;
            
            // Constructor
            VectorCanonicalAngleRasterOperator(R1 & r)
                : Superclass(r) { }

            // Evaluator function
            template <class IndexList>
            ElementType operator()(const IndexList &indices) const {
                return canonicalAngle(first(indices));
            }
        };

        // Factory function XXX
        template <typename R1>
        ENABLE_IF_T( is_raster<R1>,
        VectorCanonicalAngleRasterOperator<R1> ) canonicalAngle(R1 &r) {
            return VectorCanonicalAngleRasterOperator<R1>(r);
        }
    };
};

// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_RASTER_OPERATOR_MACROS
#include "operator-bases"

#endif
