
#ifndef INCA_RASTER_ALGORITHMS
#define INCA_RASTER_ALGORITHMS

// Import inca math tools
#include <inca/math.hpp>


// Import metaprogramming tools and simplifying macros
#include <inca/util/template-metaprogramming-macros.hpp>


namespace inca {
    namespace raster {

        // Recursive fill functor
        template <typename R1, typename E, class IndexList, inca::SizeType dim>
        struct FillSlice {
            void operator()(R1 & dst, const E & src, IndexList & it,
                       const IndexList & bases, const IndexList & extents) {
                for (it[dim] = bases[dim]; it[dim] <= extents[dim]; ++it[dim])
                    FillSlice<R1, E, IndexList, dim - 1>()
                        (dst, src, it, bases, extents);
            }
        };
        // Recursion base case
        template <typename R1, typename E, class IndexList>
        struct FillSlice<R1, E, IndexList, 0> {
            void operator()(R1 & dst, const E & src, IndexList & it,
                       const IndexList & bases, const IndexList & extents) {
                for (it[0] = bases[0]; it[0] <= extents[0]; ++it[0]) {
                    dst(it) = static_cast<typename R1::ElementType>(src);
                }
            }
        };


        // Recursive copy functor
        template <class R1, class R2, class IndexList, inca::SizeType dim>
        struct CopySlice {
            void operator()(R1 & dst, const R2 & src, IndexList & it,
                       const IndexList & bases, const IndexList & extents) {
                for (it[dim] = bases[dim]; it[dim] <= extents[dim]; ++it[dim])
                    CopySlice<R1, R2, IndexList, dim - 1>()
                        (dst, src, it, bases, extents);
            }
        };
        // Recursion base case
        template <class R1, class R2, class IndexList>
        struct CopySlice<R1, R2, IndexList, 0> {
            void operator()(R1 & dst, const R2 & src, IndexList & it,
                       const IndexList & bases, const IndexList & extents) {
                for (it[0] = bases[0]; it[0] <= extents[0]; ++it[0]) {
                    dst(it) = static_cast<typename R1::ElementType>(src(it));
                }
            }
        };

        // Recursive unary-functor-application functor
        template <typename F, class R1, class IndexList, inca::SizeType dim>
        struct ApplyUnaryFunctorToSlice {
            void operator()(F & f, R1 & r1, IndexList & it,
                            const IndexList & bases,
                            const IndexList & extents) {
                for (it[dim] = bases[dim]; it[dim] <= extents[dim]; ++it[dim])
                    ApplyUnaryFunctorToSlice<F, R1, IndexList, dim - 1>()
                        (f, r1, it, bases, extents);
            }
        };
        // Recursion base case
        template <typename F, class R1, class IndexList>
        struct ApplyUnaryFunctorToSlice<F, R1, IndexList, 0> {
            void operator()(F & f, R1 & r1, IndexList & it,
                            const IndexList & bases,
                            const IndexList & extents) {
                for (it[0] = bases[0]; it[0] <= extents[0]; ++it[0])
                    f(r1(it));
            }
        };

        // Recursive binary-functor-application functor
        template <typename F, class R1, class R2, class IndexList, inca::SizeType dim>
        struct ApplyBinaryFunctorToSlice {
            void operator()(F & f, R1 & r1, R2 & r2, IndexList & it,
                            const IndexList & bases,
                            const IndexList & extents) {
                for (it[dim] = bases[dim]; it[dim] <= extents[dim]; ++it[dim])
                    ApplyBinaryFunctorToSlice<F, R1, R2, IndexList, dim - 1>()
                        (f, r1, r2, it, bases, extents);
            }
        };
        // Recursion base case
        template <typename F, class R1, class R2, class IndexList>
        struct ApplyBinaryFunctorToSlice<F, R1, R2, IndexList, 0> {
            void operator()(F & f, R1 & r1, R2 & r2, IndexList & it,
                            const IndexList & bases,
                            const IndexList & extents) {
                for (it[0] = bases[0]; it[0] <= extents[0]; ++it[0])
                    f(r1(it), r2(it));
            }
        };

        template <typename R1, typename E>
        void fill(R1 & dst, const E & src) {
            typedef Array<IndexType, R1::dimensionality> IndexArray;

            IndexArray it = dst.bases();
            FillSlice<R1, E, IndexArray, R1::dimensionality - 1>()
                (dst, src, it, dst.bases(), dst.extents());
        }

        template <class R1, class R2>
        void copy(R1 & dst, const R2 & src) {
            typedef Array<IndexType, R1::dimensionality> IndexArray;

            IndexArray bases, extents, it;
            for (IndexType d = 0; d < R1::dimensionality; ++d) {
                bases[d] = inca::math::max(src.base(d), dst.base(d));
                extents[d] = inca::math::min(src.extent(d), dst.extent(d));
            }
            it = bases;
            CopySlice<R1, R2, IndexArray, R1::dimensionality - 1>()
                (dst, src, it, bases, extents);
        }


        // Apply an arbitrary unary functor to every element in a raster
        template <typename F, class R1>
        ENABLE_IF_T( AND3( NOT(is_raster<F>),
                           is_raster<R1>,
                           NOT(is_arbitrary_size_raster<R1>)
                         ),
        void )
        apply(F & f, R1 & r1) {
            typedef Array<IndexType, R1::dimensionality> IndexArray;

            IndexArray it = dst.bases();
            ApplyUnaryFunctorToSlice<F, R1, IndexArray, R1::dimensionality - 1>()
                (f, r1, it, r1.bases(), r1.extents());
        }

        // Apply an arbitrary unary functor to every element in a const raster
        template <typename F, class R1>
        ENABLE_IF_T( AND3( NOT(is_raster<F>),
                           is_raster<R1>,
                           NOT(is_arbitrary_size_raster<R1>)
                         ),
        void )
        apply(F & f, const R1 & r1) {
            typedef Array<IndexType, R1::dimensionality> IndexArray;

            IndexArray it = r1.bases();
            ApplyUnaryFunctorToSlice<F, const R1, IndexArray, R1::dimensionality - 1>()
                (f, r1, it, r1.bases(), r1.extents());
        }


        // Apply an arbitrary binary functor to every element in a raster
        template <typename F, class R1, class R2>
        ENABLE_IF_T( AND4( NOT(is_raster<F>),
                           is_raster<R1>,
                           is_raster<R2>,
                           OR2( NOT(is_arbitrary_size_raster<R1>),
                                NOT(is_arbitrary_size_raster<R2>)
                           )
                         ),
        void )
        apply(F & f, R1 & r1, R2 & r2) {
            typedef Array<IndexType, R1::dimensionality> IndexArray;

            IndexArray bases, extents, it;
            for (IndexType d = 0; d < R1::dimensionality; ++d) {
                bases[d] = inca::math::max(r1.base(d), r2.base(d));
                extents[d] = inca::math::min(r1.extent(d), r2.extent(d));
            }
            it = bases;
            ApplyBinaryFunctorToSlice<F, R1, R2, IndexArray, R1::dimensionality - 1>()
                (f, r1, r2, it, bases, extents);
        }

        // Apply an arbitrary binary functor to every element in a const raster
        template <typename F, class R1, class R2>
        ENABLE_IF_T( AND4( NOT(is_raster<F>),
                           is_raster<R1>,
                           is_raster<R2>,
                           OR2( NOT(is_arbitrary_size_raster<R1>),
                                NOT(is_arbitrary_size_raster<R2>)
                           )
                         ),
        void )
        apply(F & f, const R1 & r1, const R2 & r2) {
            typedef Array<IndexType, R1::dimensionality> IndexArray;

            IndexArray bases, extents, it;
            for (IndexType d = 0; d < R1::dimensionality; ++d) {
                bases[d] = inca::math::max(r1.base(d), r2.base(d));
                extents[d] = inca::math::min(r1.extent(d), r2.extent(d));
            }
            it = bases;
            ApplyBinaryFunctorToSlice<F, const R1, const R2, IndexArray, R1::dimensionality - 1>()
                (f, r1, r2, it, bases, extents);
        }

#if 0
        template <class RasterType>
        void fill(RasterType & r, const typename RasterType::ElementType & e) {
            // Make sure these types fulfill the requirements
//            function_requires< WritableRasterConcept<RasterType> >();
//            function_requires< AssignableConcept<RasterType::ElementType> >();

            // Copy the element to every cell in the raster
            typename RasterType::Iterator i;
            for (i = r.begin(); i != r.end(); ++i)
                *i = e;
        }

        template <class RasterType1, class RasterType2>
        void copy(RasterType1 & dst, const RasterType2 & src) {
            // Make sure these types fulfill the requirements
//            function_requires< WritableRasterConcept<RasterType1> >();
//            function_requires< ReadableRasterConcept<RasterType2> >();

            cerr << "Starting copy";
            
            cerr << "Copied " << count << " thingies\n";
            // Copy the element to every cell in the raster
            typename RasterType1::Iterator      di = dst.begin();
            typename RasterType2::ConstIterator si = src.begin();
            int count = 0;
            for (di = dst.begin(), si = src.begin();
              si != src.end(); ) {
                count++;
                *(di++) = *(si++);
            }
        }


        template <class RasterType, 
                  template <typename, SizeType> Solid>
        void fillInside(Raster<element_t, dim> & r,
                        const Solid<scalar_t, dim> & s,
                        const element_t & e) {
            for (i = r.begin(); i != r.end(); ++i)
                if (inside(s, i))
                    *i = e;
        }
#endif
    };
};

// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_METAPROGRAMMING_MACROS
#include <inca/util/template-metaprogramming-macros.hpp>

#endif
