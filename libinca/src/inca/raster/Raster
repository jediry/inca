/* -*- C++ -*-
 *
 * File: Raster
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      The Raster template class is an arbitrary-dimensional grid-like
 *      structure of homogeneous elements. It can be instantiated in a number
 *      of ways, to achieve a wide array of ends. The most common use is as a
 *      wrapper around an in-memory container of homogeneous elements, such as
 *      a C-style array or MultiArray, or an image structure, such as that
 *      provided by ImageMagick. Other uses for the Raster interface include
 *      user-accessible pixel buffers in a 3D graphics accelerator card, and
 *      the compile-time-optimized raster-processing expression mechanism in
 *      this package.
 *
 *      The RasterView template class implements the Raster interface
 *      functions common to all Raster implementations, specifically the
 *      following:
 *          (=) assignment operators from Raster and ElementType
 */

#ifndef INCA_RASTER_RASTER
#define INCA_RASTER_RASTER

// Import system configuration
#include <inca/inca-common.h>

// Import system configuration
#include <inca/inca-common.h>

// This is part of the Inca raster processing library
namespace inca {
    namespace raster {
        // Forward declarations
        template <class Base> class RasterView;
    };
};

// Import multi-dimensional preprocessor metaprogramming macros
#include <inca/util/multi-dimensional-macros.hpp>


template <class RasterBase>
class inca::raster::RasterView : public RasterBase {
/*---------------------------------------------------------------------------*
 | Type & constant declarations
 *---------------------------------------------------------------------------*/
public:
    // Typedefs for me and my base (implementation) class
    typedef RasterView<RasterBase>  ThisType;
    typedef RasterBase              Base;

    // Numeric types
    typedef typename Base::SizeType         SizeType;
    typedef typename Base::IndexType        IndexType;
    typedef typename Base::DifferenceType   DifferenceType;

    // Numeric list types
    typedef typename Base::ExtentList       ExtentList;
    typedef typename Base::IndexList        IndexList;

    // Iterator types
    typedef typename Base::Iterator              Iterator;
    typedef typename Base::ConstIterator         ConstIterator;
    typedef typename Base::ReverseIterator       ReverseIterator;
    typedef typename Base::ConstReverseIterator  ConstReverseIterator;

    // How many dimensions do I have?
    static const SizeType dimensionality = Base::dimensionality;

    // What type of things do I contain?
    typedef typename Base::ElementType      ElementType;
    typedef typename Base::Reference        Reference;
    typedef typename Base::ConstReference   ConstReference;
    typedef typename Base::Pointer          Pointer;
    typedef typename Base::ConstPointer     ConstPointer;


/*---------------------------------------------------------------------------*
 | Assignment operators
 *---------------------------------------------------------------------------*/
public:
    // Fill with a constant value (must be convertible to the ElementType)
    ThisType & operator=(ConstReference e) {
        fill(*this, e);
        return *this;
    }

    // Copy assignment from another RasterView object
    template <class Base2>
    constraint ThisType is resizeable
    ThisType & operator=(const RasterView<Base2> &r) {
        resize(r.extents());            // Make sure it's the right size
        copy(r, *this);                 // Copy all the elements
        return *this;                   // Return a reference
    }
    
    template <class Base2>
    constraint ThisType is not resizeable


/*---------------------------------------------------------------------------*
 | Size & shape functions
 *---------------------------------------------------------------------------*/
public:
    // Arbitrary-dimensional resize function...implemented by Base class
    template <class IndexList>
    void resize(const ExtentList &extents) { Base::resize(extents); }

    // Dimensionality-specific resize functions
    #define CREATE_DIMENSIONAL_RESIZE(DIM)                                  \
        void resize(PARAMS(DIM, int e)) {                                   \
            resize(PARAMS(DIM, e));                                         \
        }
    FOR_ALL_DIMS(CREATE_DIMENSIONAL_RESIZE);
    #undef CREATE_DIMENSIONAL_RESIZE


/*---------------------------------------------------------------------------*
 | Element accessors
 *---------------------------------------------------------------------------*/
public:
    // Arbitrary-dimensional element accessors...implemented by Base class
    template <class IndexList>
    Reference operator()(const IndexList &indices) {
        return Base::operator()(indices);
    }
    template <class IndexList>
    ConstReference operator()(const IndexList &indices) const {
        return Base::operator()(indices);
    }

    // Dimension-specific element accessors
    // These simply call the arbitrary-dimensional versions.
    #define CREATE_DIMENSIONAL_ACCESSOR(DIM)                                \
        Reference operator()(PARAMS(DIM, Index_type i)) {                   \
            BOOST_STATIC_ASSERT(dimension == DIM);                          \
            return operator()(IndexArray((PARAMS(DIM, i)));                 \
        }                                                                   \
        ConstReference operator()(PARAMS(DIM, Index_type i)) const {        \
            BOOST_STATIC_ASSERT(dimension == DIM);                          \
            return operator()(IndexArray((PARAMS(DIM, i)));                 \
        }
    FOR_ALL_DIMS(CREATE_DIMENSIONAL_ACCESSOR);
    #undef CREATE_DIMENSIONAL_ACCESSOR
};


// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_MULTI_DIM_MACROS
#include <inca/util/multi-dimensional-macros.hpp>

#endif
