/* -*- C++ -*-
 *
 * File: Raster
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      The Raster template class is an arbitrary-dimensional grid-like
 *      structure of homogeneous elements. It can be instantiated in a number
 *      of ways, to achieve a wide array of ends. The most common use is as a
 *      wrapper around an in-memory container of homogeneous elements, such as
 *      a C-style array or MultiArray, or an image structure, such as that
 *      provided by ImageMagick. Other uses for the Raster interface include
 *      user-accessible pixel buffers in a 3D graphics accelerator card, and
 *      the compile-time-optimized raster-processing expression mechanism in
 *      this package.
 *
 *      The RasterView template class implements the Raster interface
 *      functions common to all Raster implementations, specifically the
 *      following:
 *          (=) assignment operators from Raster and ElementType
 */

#ifndef INCA_RASTER_RASTER
#define INCA_RASTER_RASTER

// Import system configuration
#include <inca/inca-common.h>

// Import system configuration
#include <inca/inca-common.h>

// This is part of the Inca raster processing library
namespace inca {
    namespace raster {
        // Forward declarations
        template <class R, template <class> Holder> class PassThruRaster;
        template <class R> class ByValueRasterHolder;
        template <class R> class ByReferenceRasterHolder;
    };
};

// Import multi-dimensional preprocessor metaprogramming macros
#include <inca/util/multi-dimensional-macros.hpp>


template <class R, template <class> Holder = ByReferenceRasterHolder>
class inca::raster::PassThruRaster {
/*---------------------------------------------------------------------------*
 | Type & constant declarations
 *---------------------------------------------------------------------------*/
private:
    // Who am I?
    typedef PassThruRaster<R, Holder>   ThisType;

public:
    // The raster type that we're wrapping, and the thing that holds it
    typedef R           RasterType;
    typedef Holder<R>   RasterHolder;

    // Numeric types
    typedef inca::SizeType         SizeType;
    typedef inca::IndexType        IndexType;
    typedef inca::DifferenceType   DifferenceType;

    // How many dimensions do I have?
    static const SizeType dimensionality = Raster::dimensionality;

    // Numeric list types
    typedef Array<SizeType, dimensionality>         SizeArray;
    typedef Array<IndexType, dimensionality>        IndexArray;
    typedef Array<DifferenceType, dimensionality>   DifferenceArray;

    // Iterator types
//    typedef typename Base::Iterator              Iterator;
//    typedef typename Base::ConstIterator         ConstIterator;
//    typedef typename Base::ReverseIterator       ReverseIterator;
//    typedef typename Base::ConstReverseIterator  ConstReverseIterator;

    // What type of things do I contain?
    typedef typename R::ElementType         ElementType;
    typedef typename R::Reference           Reference;
    typedef typename R::ConstReference      ConstReference;
    typedef typename R::Pointer             Pointer;
    typedef typename R::ConstPointer        ConstPointer;


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    // Constructor
    PassThruRaster(RasterType & r) : holder(r) { }

protected:
    RasterHolder raster;


/*---------------------------------------------------------------------------*
 | Assignment operators
 *---------------------------------------------------------------------------*/
public:
    // Fill with a constant value (must be convertible to the ElementType)
    ThisType & operator=(ConstReference e) {
        fill(*this, e);
        return *this;
    }

    // Copy assignment from another RasterView object
    template <class Base2>
    constraint ThisType is resizeable
    ThisType & operator=(const RasterView<Base2> &r) {
        resize(r.extents());            // Make sure it's the right size
        copy(r, *this);                 // Copy all the elements
        return *this;                   // Return a reference
    }
    
    template <class Base2>
    constraint ThisType is not resizeable


/*---------------------------------------------------------------------------*
 | Size & shape functions
 *---------------------------------------------------------------------------*/
public:
    // Total number of elements
    SizeType size() const                   { return raster().size(); }

    // Number of elements along each dimensional axis
    SizeType size(IndexType d) const  { return raster().size(d); }
    const SizeArray & sizes() const   { return raster().sizes(); }

    // Index base (minimum index) along each dimensional axis
    IndexType base(IndexType d) const  { return raster().base(d); }
    const IndexArray & bases() const   { return raster().bases(); }

    // Index extent (maximum index) along each dimensional axis
    IndexType extent(IndexType d) const     { return raster().extent(d); }
    const IndexArray & extents() const      { return raster().extents(); }


/*---------------------------------------------------------------------------*
 | Iterator accessors
 *---------------------------------------------------------------------------*/
public:
         Iterator begin()       { return raster().begin(); }
    ConstIterator begin() const { return raster().begin(); }
         Iterator end()         { return raster().end(); }
    ConstIterator end()   const { return raster().end(); }

         ReverseIterator reverseBegin()       { return raster().reverseBegin(); }
    ConstReverseIterator reverseBegin() const { return raster().reverseBegin(); }
         ReverseIterator reverseEnd()         { return raster().reverseEnd(); }
    ConstReverseIterator reverseEnd()   const { return raster().reverseEnd(); }


/*---------------------------------------------------------------------------*
 | Element accessors
 *---------------------------------------------------------------------------*/
public:
    // Arbitrary-dimensional element accessors
    template <class IndexList>
         Reference operator()(const IndexList &indices)       { return array()(indices); }
    template <class IndexList>
    ConstReference operator()(const IndexList &indices) const { return array()(indices); }

    #define CREATE_DIMENSIONAL_ACCESSOR(DIM)                                \
        Reference operator()(PARAMS(DIM, IndexType i)) {                    \
            return array()(PARAMS(DIM, i));                                 \
        }                                                                   \
        ConstReference operator()(PARAMS(DIM, IndexType i)) const {         \
            return array()(PARAMS(DIM, i));                                 \
        }
    FOR_ALL_DIMS(CREATE_DIMENSIONAL_ACCESSOR);
    #undef CREATE_DIMENSIONAL_ACCESSOR
/*---------------------------------------------------------------------------*
 | Size & shape functions
 *---------------------------------------------------------------------------*/
public:
    // Arbitrary-dimensional resize function...implemented by Base class
    template <class IndexList>
    void resize(const ExtentList &extents) { Base::resize(extents); }

    // Dimensionality-specific resize functions
    #define CREATE_DIMENSIONAL_RESIZE(DIM)                                  \
        void resize(PARAMS(DIM, int e)) {                                   \
            resize(PARAMS(DIM, e));                                         \
        }
    FOR_ALL_DIMS(CREATE_DIMENSIONAL_RESIZE);
    #undef CREATE_DIMENSIONAL_RESIZE


/*---------------------------------------------------------------------------*
 | Element accessors
 *---------------------------------------------------------------------------*/
public:
    // Arbitrary-dimensional element accessors...implemented by Base class
    template <class IndexList>
    Reference operator()(const IndexList &indices) {
        return Base::operator()(indices);
    }
    template <class IndexList>
    ConstReference operator()(const IndexList &indices) const {
        return Base::operator()(indices);
    }

    // Dimension-specific element accessors
    // These simply call the arbitrary-dimensional versions.
    #define CREATE_DIMENSIONAL_ACCESSOR(DIM)                                \
        Reference operator()(PARAMS(DIM, Index_type i)) {                   \
            BOOST_STATIC_ASSERT(dimension == DIM);                          \
            return operator()(IndexArray((PARAMS(DIM, i)));                 \
        }                                                                   \
        ConstReference operator()(PARAMS(DIM, Index_type i)) const {        \
            BOOST_STATIC_ASSERT(dimension == DIM);                          \
            return operator()(IndexArray((PARAMS(DIM, i)));                 \
        }
    FOR_ALL_DIMS(CREATE_DIMENSIONAL_ACCESSOR);
    #undef CREATE_DIMENSIONAL_ACCESSOR
};


// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_MULTI_DIM_MACROS
#include <inca/util/multi-dimensional-macros.hpp>

#endif
