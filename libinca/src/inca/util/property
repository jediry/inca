/* -*- C++ -*-
 *
 * File: property
 *
 * Author: Ryan L. Saunders
 *
 * Copyright 2003, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      What these are, what people say about 'em, why I decided to do it anyway
 *
 *      How to implement custom getter/setter
 *
 *      Semantics of the different types of properties.
 *
 *      The macro-pseudolanguage idiom.
 *
 *      Need to make sure that invalid uses don't compile.
 *
 *      Warn about "read-only" meaning.
 *
 *      meaning of rw/ro, and {}/ca/cm/cam
 *
 *      user synatx: XX_property macros, property_accessor, etc.
 *
 *      the necessity of constructor init and ThisType
 *
 *      Traits are really needed to create operator overloads
 *      Can we also determine whether it's safe to allow non-const refs?
 *
 *      The property family of template classes implement C#-style properties,
 *      in which a value is wrapped by an object which controls access via
 *      accessor functions, but can still be accessed syntactically as a plain
 *      variable (via overloaded '=' and cast operators). Properties may be
 *      made public, protected, private, static or const and (as a handy
 *      extension) have a default value (which need not be initialized in the
 *      owner's constructor(s)).
 *
 *      Developers warning:
 *
 *               **** Abandon all hope, ye who enter here! ****
 *
 *      This is some of the nastiest-looking code I've ever written. Sorry
 *      about that, but I couldn't find a way to do this cleanly; since C++
 *      templates don't seem to support the kinds of features I needed, I
 *      had to resort to a combination of C preprocessor, template partial
 *      specialization, and inheritance to get the effect I wanted.
 *
 *      FIXME:? What about the case where we want to allow access to non-const
 *      functions of the target, but not allow assignment to the target. Is
 *      this possible?
 */

#ifndef INCA_UTIL_PROPERTY
#define INCA_UTIL_PROPERTY

// Import system configuration
#include <inca/inca-common.h>


// Disable the annoying "this : used in base member initializer list" warning
// under Visual Studio
#pragma warning (disable : 4355)

/*****************************************************************************
 * This macro sets up the additional typedefs, etc. that are needed so that
 * properties can be declared without having to pass the owner's type in as
 * a preprocessor parameter.
 *****************************************************************************/
#define PROPERTY_OWNING_OBJECT(TYPE) private: typedef TYPE ThisType;


/*****************************************************************************
 * This macro declares typedefs based on the property type. These typedefs
 * are used by the other macros to declare functions and variables.
 *****************************************************************************/
#define PROPERTY_TYPEDEFS(TYPE)                                             \
        /* Template typedefs */                                             \
        typedef TYPE                type;                                   \
        typedef TYPE &              reference;                              \
        typedef const TYPE &        const_reference;                        \
        typedef TYPE *              pointer;                                \
        typedef shared_ptr<TYPE>    shared_pointer;                         \
        typedef ThisType            Owner;


/*****************************************************************************
 * These macros declare the variables used internally by the property object.
 *****************************************************************************/
#define PROPERTY_VARIABLES                                                  \
        Owner & owner;                                                      \
        mutable bool initialized;                                           \
        type defaultValue;


#define PTR_PROPERTY_VARIABLES                                              \
        Owner & owner;                                                      \
        mutable bool initialized;                                           \
        shared_pointer defaultValue;


#define LIST_PROPERTY_VARIABLES                                             \
        Owner & owner;


/*****************************************************************************
 * These macros declare the constructors for the property object. The first
 * constructor uses the default specified in the property definition, while
 * the second allows this default to be overridden from the owner object's
 * constructor.
 *****************************************************************************/
#define PROPERTY_CONSTRUCTORS(NAME, DEFAULT)                                \
    /* Constructor with the default initializion */                         \
    property_ ## NAME(Owner * own)                                          \
        : owner(*own), initialized(false), defaultValue(DEFAULT) { }        \
    /* Constructor with an explicit initialization */                       \
    property_ ## NAME(Owner * own, type def)                                \
        : owner(*own), initialized(false), defaultValue(def) { }


#define PTR_PROPERTY_CONSTRUCTORS(NAME, DEFAULT)                            \
    /* Constructor with the default initializion */                         \
    property_ ## NAME(Owner * own)                                          \
        : owner(*own), initialized(false), defaultValue(pointer(DEFAULT)) { }\
    /* Constructor with an explicit initialization */                       \
    property_ ## NAME(Owner * own, pointer def)                             \
        : owner(*own), initialized(false), defaultValue(def) { }            \
    /* Constructors with an explicit initialization */                      \
    property_ ## NAME(Owner * own, shared_pointer def)                      \
        : owner(*own), initialized(false), defaultValue(def) { }


#define LIST_PROPERTY_CONSTRUCTORS(NAME)                                    \
    /* Constructor with the default initializion */                         \
    property_ ## NAME(Owner * own) : owner(*own) { }


/*****************************************************************************
 * These macros declare the equality comparison operators for seeing if the
 * wrapped value is equivalent to another value. These require that the ==
 * operator is defined appropriately.
 *****************************************************************************/
#define PROPERTY_COMPARISONS(NAME)                                          \
    /* Comparison operators */                                              \
    bool operator==(const_reference v) const { return get() == v; }         \
    bool operator!=(const_reference v) const { return !(get() == v); }


/*****************************************************************************
 * These macros declare the accessor/mutator operators and functions belonging
 * to the property object itself. No parameters are needed because type
 * definitions are pulled from the class's typedefs and no custom
 * code belongs here.
 *****************************************************************************/
#define PROPERTY_ACCESSORS(NAME)                                            \
    /* Getter operator and function */                                      \
    operator       reference ()        { return get(); }                    \
    operator const_reference ()  const { return get(); }                    \
          reference operator()()       { return get(); }                    \
    const_reference operator()() const { return get(); }                    \
    reference get() {                                                       \
        return const_cast<reference>(                                       \
                const_cast<const property_ ## NAME *>(this)->get()          \
        );                                                                  \
    }                                                                       \
    const_reference get() const {                                           \
        if (!initialized) {    /* Handle the default argument */            \
            initialized = true;                                             \
            owner.set_ ## NAME(defaultValue);                               \
        }                                                                   \
        return owner.get_ ## NAME();                                        \
    }

#define PROPERTY_MUTATORS(NAME)                                             \
    /* Setter operator and function */                                      \
    void operator=(const_reference v) { set(v); }                           \
    void set(const_reference v) {                                           \
        if (!initialized)      /* Ignore the default argument */            \
            initialized = true;                                             \
        return owner.set_ ## NAME(v);                                       \
    }


#define PTR_PROPERTY_ACCESSORS(NAME)                                        \
    /* Getter operators and function */                                     \
    operator shared_pointer()   const { return get(); }                     \
    operator pointer()          const { return get().get(); }               \
    pointer operator->()        const { return get().get(); }               \
    operator const_reference()  const { return *get(); }                    \
    operator       reference()        { return *get(); }                    \
    shared_pointer operator()() const { return get(); }                     \
    shared_pointer get() const {                                            \
        if (!initialized) {    /* Handle the default argument */            \
            initialized = true;                                             \
            owner.set_ ## NAME(defaultValue);                               \
        }                                                                   \
        return owner.get_ ## NAME();                                        \
    }

#define PTR_PROPERTY_MUTATORS(NAME)                                         \
    /* Setter operators and function */                                     \
    void operator=(pointer p) { set(shared_pointer(p)); }                   \
    void operator=(shared_pointer p) { set(p); }                            \
    void set(shared_pointer p) {                                            \
        if (!initialized)      /* Ignore the default argument */            \
            initialized = true;                                             \
        return owner.set_ ## NAME(p);                                       \
    }


#define LIST_PROPERTY_ACCESSORS(NAME)                                       \
    /* Getter operators and function */                                     \
    const_reference operator [](index_t i) const { return get(i); }         \
    const_reference get(index_t i) const {                                  \
        return owner.get_ ## NAME(i);                                       \
    }                                                                       \
    size_t size() const { return owner. NAME ## _size(); }

#define LIST_PROPERTY_MUTATORS(NAME)                                        \
    /* Setter operators and function */                                     \
    reference operator [](index_t i) { return get(i); }                     \
    reference get(index_t i) {                                              \
        return owner.get_ ## NAME(i);                                       \
    }                                                                       \
    void add(const_reference v) { owner.add_ ## NAME(v); }


/*****************************************************************************
 * These macros declare the property objects that are our syntactic
 * "front-ends" for the real data handling, which is done in the property
 * owner's functions.
 *****************************************************************************/
#define RO_PROPERTY_CLASS(TYPE, NAME, DEFAULT)                              \
    /* Property object class definition w/ instantiation */                 \
    class property_ ## NAME {                                               \
    public:                                                                 \
        PROPERTY_TYPEDEFS(TYPE);                                            \
        PROPERTY_CONSTRUCTORS(NAME, DEFAULT);                               \
        PROPERTY_COMPARISONS(NAME);                                         \
        PROPERTY_ACCESSORS(NAME);                                           \
        PROPERTY_MUTATORS(NAME);                                            \
        PROPERTY_VARIABLES;                                                 \
    };

#define RW_PROPERTY_CLASS(TYPE, NAME, DEFAULT)                              \
    /* Property object class definition w/ instantiation */                 \
    class property_ ## NAME {                                               \
    public:                                                                 \
        PROPERTY_TYPEDEFS(TYPE);                                            \
        PROPERTY_CONSTRUCTORS(NAME, DEFAULT);                               \
        PROPERTY_ACCESSORS(NAME);                                           \
        PROPERTY_MUTATORS(NAME);                                            \
        PROPERTY_VARIABLES;                                                 \
    };

#define RO_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT)                          \
    /* Property object class definition w/ instantiation */                 \
    class property_ ## NAME {                                               \
    public:                                                                 \
        PROPERTY_TYPEDEFS(TYPE);                                            \
        PTR_PROPERTY_CONSTRUCTORS(NAME, DEFAULT);                           \
        PTR_PROPERTY_ACCESSORS(NAME);                                       \
        PTR_PROPERTY_MUTATORS(NAME);                                        \
        PTR_PROPERTY_VARIABLES;                                             \
    };

#define RW_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT)                          \
    /* Property object class definition w/ instantiation */                 \
    class property_ ## NAME {                                               \
    public:                                                                 \
        PROPERTY_TYPEDEFS(TYPE);                                            \
        PTR_PROPERTY_CONSTRUCTORS(NAME, DEFAULT);                           \
        PTR_PROPERTY_ACCESSORS(NAME);                                       \
        PTR_PROPERTY_MUTATORS(NAME);                                        \
        PTR_PROPERTY_VARIABLES;                                             \
    };

#define RO_LIST_PROPERTY_CLASS(TYPE, NAME)                                  \
    /* Property object class definition w/ instantiation */                 \
    class property_ ## NAME {                                               \
    public:                                                                 \
        PROPERTY_TYPEDEFS(TYPE);                                            \
        LIST_PROPERTY_CONSTRUCTORS(NAME);                                   \
        LIST_PROPERTY_ACCESSORS(NAME);                                      \
    private:                                                                \
        LIST_PROPERTY_MUTATORS(NAME);                                       \
        LIST_PROPERTY_VARIABLES;                                            \
    };

#define RW_LIST_PROPERTY_CLASS(TYPE, NAME)                                  \
    /* Property object class definition w/ instantiation */                 \
    class property_ ## NAME {                                               \
    public:                                                                 \
        PROPERTY_TYPEDEFS(TYPE);                                            \
        LIST_PROPERTY_CONSTRUCTORS(NAME);                                   \
        LIST_PROPERTY_ACCESSORS(NAME);                                      \
        LIST_PROPERTY_MUTATORS(NAME);                                       \
    private:                                                                \
        LIST_PROPERTY_VARIABLES;                                            \
    };


/*****************************************************************************
 * These macros create the property owner's variables, which store the actual
 * data wrapped by the property.
 *****************************************************************************/
#define RO_PROPERTY_OWNER_VARIABLES(TYPE, NAME)                             \
    const property_ ## NAME NAME;                                           \
    TYPE _ ## NAME;

#define RW_PROPERTY_OWNER_VARIABLES(TYPE, NAME)                             \
    property_ ## NAME NAME;                                                 \
    TYPE _ ## NAME;

#define RO_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME)                         \
    const property_ ## NAME NAME;                                           \
    shared_ptr<TYPE> _ ## NAME;

#define RW_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME)                         \
    property_ ## NAME NAME;                                                 \
    shared_ptr<TYPE> _ ## NAME;

#define RO_LIST_PROPERTY_OWNER_VARIABLES(TYPE, NAME)                        \
    const property_ ## NAME NAME;                                           \
    vector<TYPE> _ ## NAME;

#define RW_LIST_PROPERTY_OWNER_VARIABLES(TYPE, NAME)                        \
    property_ ## NAME NAME;                                                 \
    vector<TYPE> _ ## NAME;


/*****************************************************************************
 * These macros create the default accessor/mutator functions for the
 * property's owner. The default implementations for these simply assign and
 * return the value of a protected variable with the same name as the property
 * with a preceding underscore.
 *****************************************************************************/

// These macros expand to the function signatures
#define property_get(TYPE, NAME)     get_ ## NAME() const
#define property_set(TYPE, NAME)     set_ ## NAME(const TYPE & value)

#define ptr_property_get(TYPE, NAME) get_ ## NAME() const
#define ptr_property_set(TYPE, NAME) set_ ## NAME(shared_ptr<TYPE> value)

#define list_property_size(TYPE, NAME)   NAME ## _size() const
#define list_property_get(TYPE, NAME)    get_ ## NAME(index_t index) const
#define list_property_set(TYPE, NAME)    get_ ## NAME(index_t index)
#define list_property_add(TYPE, NAME)    add_ ## NAME(const TYPE & value)
#define list_property_delete(TYPE, NAME) delete_ ## NAME(index_t index)

// These are the full function prototypes (with return type)
#define PROPERTY_GET_PROTOTYPE(TYPE, NAME)                                  \
    const TYPE & property_get(TYPE, NAME)
#define PROPERTY_SET_PROTOTYPE(TYPE, NAME)                                  \
    void property_set(TYPE, NAME)
#define PTR_PROPERTY_GET_PROTOTYPE(TYPE, NAME)                              \
    shared_ptr<TYPE> ptr_property_get(TYPE, NAME)
#define PTR_PROPERTY_SET_PROTOTYPE(TYPE, NAME)                              \
    void ptr_property_set(TYPE, NAME)
#define LIST_PROPERTY_SIZE_PROTOTYPE(TYPE, NAME)                            \
    size_t list_property_size(TYPE, NAME)
#define LIST_PROPERTY_GET_PROTOTYPE(TYPE, NAME)                             \
    const TYPE & list_property_get(TYPE, NAME)
#define LIST_PROPERTY_SET_PROTOTYPE(TYPE, NAME)                             \
    TYPE & list_property_set(TYPE, NAME)
#define LIST_PROPERTY_ADD_PROTOTYPE(TYPE, NAME)                             \
    void list_property_add(TYPE, NAME)
#define LIST_PROPERTY_DELETE_PROTOTYPE(TYPE, NAME)                          \
    void list_property_delete(TYPE, NAME)

// Default property getter function implementation
#define DEFAULT_PROPERTY_GET(TYPE, NAME)                                    \
    PROPERTY_GET_PROTOTYPE(TYPE, NAME) { return _ ## NAME; }

// Default property setter function implementation
#define DEFAULT_PROPERTY_SET(TYPE, NAME)                                    \
    PROPERTY_SET_PROTOTYPE(TYPE, NAME) { _ ## NAME = value; }


// Default pointer property getter function implementation
#define DEFAULT_PTR_PROPERTY_GET(TYPE, NAME)                                \
    PTR_PROPERTY_GET_PROTOTYPE(TYPE, NAME) { return _ ## NAME; }

// Default pointer property setter function implementation
#define DEFAULT_PTR_PROPERTY_SET(TYPE, NAME)                                \
    PTR_PROPERTY_SET_PROTOTYPE(TYPE, NAME) { _ ## NAME = value; }


// Default list property size implementation
#define DEFAULT_LIST_PROPERTY_SIZE(TYPE, NAME)                              \
    LIST_PROPERTY_SIZE_PROTOTYPE(TYPE, NAME) { return _ ## NAME.size(); }

// Default list property get implementation
#define DEFAULT_LIST_PROPERTY_GET(TYPE, NAME)                               \
    LIST_PROPERTY_GET_PROTOTYPE(TYPE, NAME) { return _ ## NAME[index]; }

// Default list property set implementation
#define DEFAULT_LIST_PROPERTY_SET(TYPE, NAME)                               \
    LIST_PROPERTY_SET_PROTOTYPE(TYPE, NAME) { return _ ## NAME[index]; }

// Default list property add implementation
#define DEFAULT_LIST_PROPERTY_ADD(TYPE, NAME)                               \
    LIST_PROPERTY_ADD_PROTOTYPE(TYPE, NAME) { return _ ## NAME.push_back(value); }

// Default list property add implementation
#define DEFAULT_LIST_PROPERTY_DELETE(TYPE, NAME)                            \
    LIST_PROPERTY_DELETE_PROTOTYPE(TYPE, NAME) { }


/*****************************************************************************
 * Now we come to the payoff. These macros create the different types of
 * properties (using the above macros) and are the only ones that should be
 * directly invoked by the user.
 *****************************************************************************/
// A read-only primitive property with default getter/setter
#define ro_property(TYPE, NAME, DEFAULT)                                    \
public:                                                                     \
    RO_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RO_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                                \
    DEFAULT_PROPERTY_GET(TYPE, NAME);                                       \
    DEFAULT_PROPERTY_SET(TYPE, NAME);

// A read-only primitive property with default getter/setter
#define rw_property(TYPE, NAME, DEFAULT)                                    \
public:                                                                     \
    RW_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RW_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                                \
    DEFAULT_PROPERTY_GET(TYPE, NAME);                                       \
    DEFAULT_PROPERTY_SET(TYPE, NAME);

// A read-only primitive property with no default getter
#define ro_property_custom_get(TYPE, NAME, DEFAULT)                         \
public:                                                                     \
    RO_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RO_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                                \
    DEFAULT_PROPERTY_SET(TYPE, NAME);

// A read-write primitive property with no default getter
#define rw_property_custom_get(TYPE, NAME, DEFAULT)                         \
public:                                                                     \
    RW_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RW_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                                \
    DEFAULT_PROPERTY_SET(TYPE, NAME);

// A read-only primitive property with no default setter
#define ro_property_custom_set(TYPE, NAME, DEFAULT)                         \
public:                                                                     \
    RO_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RO_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                                \
    DEFAULT_PROPERTY_GET(TYPE, NAME);

// A read-write primitive property with no default setter
#define rw_property_custom_set(TYPE, NAME, DEFAULT)                         \
public:                                                                     \
    RW_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RW_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                                \
    DEFAULT_PROPERTY_GET(TYPE, NAME);

// A read-only primitive property with no default functions
#define ro_property_custom_get_set(TYPE, NAME, DEFAULT)                     \
public:                                                                     \
    RO_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RO_PROPERTY_OWNER_VARIABLES(TYPE, NAME);

// A read-write primitive property with no default functions
#define rw_property_custom_get_set(TYPE, NAME, DEFAULT)                     \
public:                                                                     \
    RW_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                                 \
    RW_PROPERTY_OWNER_VARIABLES(TYPE, NAME);


// A read-only pointer property with default getter/setter
#define ro_ptr_property(TYPE, NAME, DEFAULT)                                \
public:                                                                     \
    RO_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RO_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                            \
    DEFAULT_PTR_PROPERTY_GET(TYPE, NAME);                                   \
    DEFAULT_PTR_PROPERTY_SET(TYPE, NAME);

// A read-write pointer property with default getter/setter
#define rw_ptr_property(TYPE, NAME, DEFAULT)                                \
public:                                                                     \
    RW_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RW_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                            \
    DEFAULT_PTR_PROPERTY_GET(TYPE, NAME);                                   \
    DEFAULT_PTR_PROPERTY_SET(TYPE, NAME);

// A read-only pointer property with no default getter
#define ro_ptr_property_custom_get(TYPE, NAME, DEFAULT)                     \
public:                                                                     \
    RO_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RO_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                            \
    DEFAULT_PTR_PROPERTY_SET(TYPE, NAME);

// A read-write pointer property with no default getter
#define rw_ptr_property_custom_get(TYPE, NAME, DEFAULT)                     \
public:                                                                     \
    RW_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RW_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                            \
    DEFAULT_PTR_PROPERTY_SET(TYPE, NAME);

// A read-only pointer property with no default setter
#define ro_ptr_property_custom_set(TYPE, NAME, DEFAULT)                             \
public:                                                                     \
    RO_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RO_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                            \
    DEFAULT_PTR_PROPERTY_GET(TYPE, NAME);

// A read-write pointer property with no default setter
#define rw_ptr_property_custom_set(TYPE, NAME, DEFAULT)                             \
public:                                                                     \
    RW_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RW_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                            \
    DEFAULT_PTR_PROPERTY_GET(TYPE, NAME);

// A read-only pointer property with no default functions
#define ro_ptr_property_custom_get_set(TYPE, NAME, DEFAULT)                 \
public:                                                                     \
    RO_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RO_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);

// A read-write pointer property with no default functions
#define rw_ptr_property_custom_get_set(TYPE, NAME, DEFAULT)                 \
public:                                                                     \
    RW_PTR_PROPERTY_CLASS(TYPE, NAME, DEFAULT);                             \
    RW_PTR_PROPERTY_OWNER_VARIABLES(TYPE, NAME);

// A read-only list property with default size/get/set/add/delete
#define ro_list_property(TYPE, NAME)                                        \
public:                                                                     \
    RO_LIST_PROPERTY_CLASS(TYPE, NAME);                                     \
    RO_LIST_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                           \
    DEFAULT_LIST_PROPERTY_SIZE(TYPE, NAME);                                 \
    DEFAULT_LIST_PROPERTY_GET(TYPE, NAME);                                  \
    DEFAULT_LIST_PROPERTY_SET(TYPE, NAME);                                  \
    DEFAULT_LIST_PROPERTY_ADD(TYPE, NAME);                                  \
    DEFAULT_LIST_PROPERTY_DELETE(TYPE, NAME);

// A read-write list property with default size/get/set/add/delete
#define rw_list_property(TYPE, NAME)                                        \
public:                                                                     \
    RW_LIST_PROPERTY_CLASS(TYPE, NAME);                                     \
    RW_LIST_PROPERTY_OWNER_VARIABLES(TYPE, NAME);                           \
    DEFAULT_LIST_PROPERTY_SIZE(TYPE, NAME);                                 \
    DEFAULT_LIST_PROPERTY_GET(TYPE, NAME);                                  \
    DEFAULT_LIST_PROPERTY_SET(TYPE, NAME);                                  \
    DEFAULT_LIST_PROPERTY_ADD(TYPE, NAME);                                  \
    DEFAULT_LIST_PROPERTY_DELETE(TYPE, NAME);

#endif
