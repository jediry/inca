/** -*- C++ -*-
 *
 * \file Timer
 *
 * Author: Ryan L. Saunders <rls@tamu.edu>
 *
 * Copyright 2003, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      The Timer class is a real-time timer capable of sending events to
 *      listening objects at periodic intervals and whenever a significant
 *      change occurs (e.g., the timer stops). This can be used to drive a
 *      real-time process. It can also be used as a simple pollable timer.
 *
 *      Timer is capable of running in either direction (i.e., forward or
 *      backward), and may be configured to stop when it reaches a limit
 *      (either the minimum or maximum value, which may be configured as well),
 *      to loop around to the other limit, or to bounce back in the opposite
 *      direction.
 *
 *      Internally, the Timer uses an integral number of clock ticks
 *      ('clocks'), which it converts to the scalar type specified as the
 *      first template parameter. The spacing between clock ticks (and thus
 *      the actual precision of the Timer) is operating system dependent. Most
 *      public functions of Timer use the scalar type, though it is possible
 *      to directly manipulate the internal 'clocks' value.
 *
 *      How much the timer advances in "virtual time" for any given amount of
 *      real time depends on the value of 'timeWarpFactor'. If this is 1.0,
 *      the timer runs in real-time. Values greater than 1.0 will cause the
 *      timer to run faster than real-time, while values between 0.0 and 1.0
 *      will cause the timer to run slower. Negative values are not permitted.
 *
 *      If configured to generate events, the Timer will generate "pulses" at
 *      fixed (user-specified) intervals. Set 'pulseInterval' to zero to
 *      disable pulses. Note that increasing 'pulseInterval' and decreasing
 *      'timeWarpFactor' have similar effects, since in both cases the pulses
 *      will come more slowly (in real-time), but in the second case the flow
 *      of virtual-time has been slowed down, so that the time values
 *      associated with each successive pulse will increase more slowly. For
 *      example, consider the pulses generated by the following two timers
 *      (the pulses will occur simultaneously in real-time, but note the
 *      difference in virtual time):
 *                      Timer 1                     Timer 2
 *                  pulseInterval = 2.0         pulseInterval = 1.0
 *                  timeWarpFactor = 2.0        timeWarpFactor = 1.0
 *                  --------------------        --------------------
 *          Pulse 1         0.0                         0.0
 *          Pulse 2         2.0                         1.0
 *          Pulse 3         4.0                         2.0
 *          Pulse 4         6.0                         3.0
 *
 *      If pulse events are desired the update() function must be called
 *      regularly by some thread in the program. If it is not called
 *      frequently enough, then the Timer will be forced either to skip some
 *      of the pulses that it would have sent in order to "keep up", or to
 *      slow down from real-time in order not to skip pulses; this is
 *      controlled by the 'maySkipPulses' parameter.
 *
 * Usage:
 *      The general running of the Timer is controlled by the normal
 *      "stopwatch" functions start(), stop(), and reset(). Additionally, the
 *      "running" state of the Timer can be switched using the toggleRunning()
 *      function. The direction of the Timer can be set manually using the
 *      setReversed(bool) or toggleReversed() functions.
 *
 *      The Timer class may be used as an event generator, as a pollable
 *      timer, or both, depending on what effect is desired.
 *
 *      To use the Timer as an event generator, you must:
 *          1) instantiate the Timer template with generateEvents = true
 *          2) register one or more objects implementing the TimerListener
 *             interface. These objects must be managed by Boost shared_ptrs.
 *          3) arrange for the Timer's update() function to be called
 *             periodically by your program (e.g., from your glutIdleFunc)
 *
 *      Once set up in this way, the Timer will send events to each listening
 *      object. There are 5 distinct events that are sent:
 *          1) timerStarted  -- when the Timer was stopped and begins running
 *          2) timedStopped  -- when the Timer was running and is stopped
 *          3) timerSet      -- when the Timer is explicitly set to a new value
 *                              either via setTimer() or via reset()
 *          5) timerReversed -- when the direction of the Timer is reversed
 *          4) timerPulsed   -- when (at least) 'pulseInterval' units of
 *                              virtual-time have elapsed
 *
 *      The periodic call to update() is only necessary if you are interested
 *      in receiving pulses. If all you want is to receive timerStarted,
 *      timerStopped and timerSet events, it is not necessary to arrange for
 *      update() to be called at all. Of course, if you do not use the pulses,
 *      you will have to query the timer manually, as described below.
 *
 *      If you don't care to receive any events at all and just want to, poll
 *      the Timer, you may instantiate Timer with generateEvents = false (it
 *      will still work fine if you use generateEvents = true, but making this
 *      false will result in a smaller and slightly faster Timer object). To
 *      query the current value of the timer, you may use the time() and
 *      setTime() functions, or the short-hand operator overloads of () and =:
 *          float currentTime = timer();
 *          timer = currentTime;
 *      Also, it is allowed to get and set the internally used integral type
 *      using the elapsedClocks() and setElapsedClocks() functions.
 *
 * Implementation Note:
 *      This implementation is not thread-safe. Maybe I'll fix it later, if
 *      I need to and if I can figure out what exactly a "thread safe timer"
 *      would be...
 *
 * Things to doc:
 *      How we handle pulses around extrema
 *
 * Things to test:
 *      Pulsing
 *      Notifiers (especially dead listener culling)
 *
 * Unsolved questions:
 *      Can/should we support integral scalar types?
 *      What happens if we change timeWarpFactor mid-use?
 */

#ifndef INCA_UTIL_TIMER
#define INCA_UTIL_TIMER

// Import system configuration
#include <inca/inca-common.h>

// Import augmented enumeration mechanism
#include "Enumeration.hpp"

// This is part of the Inca utilities collection
namespace inca {
    // Forward declarations
    template <typename scalar> class TimerListener;
    template <typename scalar, bool generateEvents = false> class Timer;
    template <typename scalar, bool generateEvents> class TimerEventSupport;
    template <typename scalar> class TimerEventSupport<scalar, true>;

    // OS-integration function prototypes (implemented elsewhere)
    clock_t getSystemClockFrequency();
    clock_t getSystemClocks();

    // What do we do when we hit one end or the other?
    INCA_ENUM( BoundaryResponse,
             ( Stop, ( Bounce, ( Loop, BOOST_PP_NIL ) ) ) );
};

namespace std {
    // IOStream writer operator for the BoundaryResponse enumeration
//     inline ostream & operator<<(ostream &o, inca::BoundaryResponse r) {
//         switch (r) {
//             case inca::Stop:   return o << "Stop";
//             case inca::Bounce: return o << "Bounce";
//             case inca::Loop:   return o << "Loop";
//             default:           return o << "Invalid BoundaryReponse(" << int(r) << ')';
//         }
//     }

    // IOStream writer operator for the BoundaryResponse enumeration
    /*inline std::ostream & operator<<(std::ostream &o, inca::BoundaryResponse r) {
        switch (r) {
            case inca::Stop:   return o << "Stop";
            case inca::Bounce: return o << "Bounce";
            case inca::Loop:   return o << "Loop";
            default:           return o << "Invalid BoundaryReponse(" << int(r) << ')';
        }
    }*/
};

// Import numeric limits for primitive types
#include <limits>

// Import our collection of weakly-help shared pointers
#include "weak_ptr_set"


/*****************************************************************************
 * Classes that want to be notified when timer events occur need to inherit
 * from this class.
 *****************************************************************************/
template <typename scalar>
class inca::TimerListener {
public:
    // Definition of the timer scalar type
    typedef scalar timer_t;

    // Listener callback functions
    virtual void timerStarted(timer_t time) { }
    virtual void timerStopped(timer_t time) { }
    virtual void timerSet(timer_t time) { }
    virtual void timerReversed(timer_t time) { }
    virtual void timerPulsed(timer_t time) { }
};


/*****************************************************************************
 * The TimerEventSupport class, which handles notifying listeners of events
 *****************************************************************************/
// Default (dummy) implementation
template <typename scalar, bool enableEvents>
class inca::TimerEventSupport {
protected:
    void fireStarted(scalar time) { }
    void fireStopped(scalar time) { }
    void fireSet(scalar time) { }
    void fireReversed(scalar time) { }
    void firePulsed(scalar time) { }
};

// Specialization incorporating notification of objects held by shared_ptr
template <typename scalar>
class inca::TimerEventSupport<scalar, true> {
/*---------------------------------------------------------------------------*
 | Type definitions
 *---------------------------------------------------------------------------*/
public:
    // Scalar type definitions
    typedef scalar scalar_t;
    typedef scalar scalar_arg_t;

    // Definition of listener notification stuff
    typedef TimerListener<scalar>                   Listener;
    typedef weak_ptr_set<Listener>                  ListenerSet;
    typedef typename ListenerSet::shared_pointer    ListenerPtr;


/*---------------------------------------------------------------------------*
 | Timer-listener functions: other objects that inherit from TimerListener
 | may register themselves to receive notifications when various types of
 | timer events occur.
 *---------------------------------------------------------------------------*/
public:
    // Listener management
    void addTimerListener(ListenerPtr ls) {
        listeners.insert(ls);
    }

    void removeTimerListener(ListenerPtr ls) {
        listeners.erase(ls);
    }

protected:
    // Send timerStarted events to each listener who is still alive
    void fireStarted(scalar_arg_t time) {
        typename ListenerSet::iterator i;
        for (i = listeners.begin(); i != listeners.end(); ++i)
            (*i)->timerStarted(time);
    }

    // Send timerStopped events to each listener who is still alive
    void fireStopped(scalar_arg_t time) {
        typename ListenerSet::iterator i;
        for (i = listeners.begin(); i != listeners.end(); ++i)
            (*i)->timerStopped(time);
    }

    // Send timerSet events to each listener who is still alive
    void fireSet(scalar_arg_t time) {
        typename ListenerSet::iterator i;
        for (i = listeners.begin(); i != listeners.end(); ++i)
            (*i)->timerSet(time);
    }

    // Send timerSet events to each listener who is still alive
    void fireReversed(scalar_arg_t time) {
        typename ListenerSet::iterator i;
        for (i = listeners.begin(); i != listeners.end(); ++i)
            (*i)->timerReversed(time);
    }

    // Sends timerPulsed events to each listener who is still alive.
    // Prints a warning if this timer was compiled w/o notification support.
    void firePulsed(scalar_arg_t time) {
        typename ListenerSet::iterator i;
        for (i = listeners.begin(); i != listeners.end(); ++i)
            (*i)->timerPulsed(time);
    }

    // This little guy helps us manage our "audience"
    ListenerSet listeners;
};


/*****************************************************************************
 * The Timer class, documented extensively above.
 *****************************************************************************/
template <typename scalar, bool generateEvents>
class inca::Timer : public TimerEventSupport<scalar, generateEvents> {
/*---------------------------------------------------------------------------*
 | Type definitions
 *---------------------------------------------------------------------------*/
public:
    // Definition of the timer scalar type (representing virtual time amounts)
    //INCA_MATH_SCALAR_TYPES(scalar, IS_WITHIN_TEMPLATE);
    typedef scalar scalar_t;
    typedef scalar scalar_arg_t;


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    explicit Timer(scalar_arg_t startTime     = scalar_t(0),
                   scalar_arg_t minTime       = scalar_t(-3.4e+38),
                   scalar_arg_t maxTime       = scalar_t( 3.4e+38),
//                   scalar_arg_t minTime       = inca::math::scalar_traits<scalar>::min(),
//                   scalar_arg_t maxTime       = inca::math::scalar_traits<scalar>::max(),
                   scalar_arg_t pulseInterval = scalar_t(0.0),
                   scalar_arg_t timeWarp      = scalar_t(1.0))
            : _running(false), _reversed(false), _maySkipPulses(true),
              _boundaryResponse(Stop) {

        // timeWarpFactor() and systemClockFrequency() must be valid
        // before we can do anything else
        querySystemClockFrequency();
        setTimeWarpFactor(timeWarp);
        setPulseInterval(pulseInterval);

        // Convert everything into clock_t's
        _minimumTimeClocks = timeToClocks(minTime);
        _maximumTimeClocks = timeToClocks(maxTime);

        // Do some sanity checks on our bounds
        if (_minimumTimeClocks >= _maximumTimeClocks) {
            // Fix it...
            _minimumTimeClocks = timeToClocks(scalar_t(-3.4e+38));
            _maximumTimeClocks = timeToClocks(scalar_t( 3.4e+38));
//            _minimumTimeClocks = timeToClocks(scalar_traits::min());
//            _maximumTimeClocks = timeToClocks(scalar_traits::max());

            // Complain about it...
            INCA_WARNING( "Timer(): requested bounds ["
                          << minTime << ", " << maxTime
                          <<  "] are invalid -- defaulting to ["
                          << clocksToTime(_minimumTimeClocks) << ", "
                          << clocksToTime(_maximumTimeClocks) << "]" )
        }

        // Make sure our initial time is in the legal range
        setElapsedClocks(timeToClocks(startTime));// This will catch out-of-bounds
        _initialTimeClocks = elapsedClocks();
    }

    /**
     * Queries the operating system's clock frequency and stores this value
     * for future use (it is assumed never to change).
     */
    void querySystemClockFrequency() {
        _systemClockFrequency = getSystemClockFrequency();
    }


/*---------------------------------------------------------------------------*
 | Timer update functions
 *---------------------------------------------------------------------------*/
public:
    /**
     * Updates the timer based on the current time reported by the operating
     * system. This function must be run periodically (e.g., in an event loop
     * or from its own thread) in order for pulse events to be generated
     * correctly. It is not necessary for you to do this if you only wish
     * to use the timer as a stopwatch, or if you only need start/stop/set
     * events, as this function is called by various other functions, such as
     * stop() and set(time).
     */
    void update() {
        if (running()) {
            // Calculate the elapsed clock ticks and advance counter
            clock_t newClocks = getSystemClocks();
            clock_t deltaClocks = newClocks - _lastSystemClocks;
            _lastSystemClocks = newClocks;

            // If we're going in reverse, we negate our delta
            if (reversed()) deltaClocks = -deltaClocks;

            // Add this to our internal counter and check boundary conditions
            setInternalCounter(elapsedClocks() + deltaClocks);

            // See if we need to pulse anybody
            if (generateEvents && std::abs(_pulseIntervalClocks) > 0) {
                int missed = std::abs(_lastPulseClocks - elapsedClocks())
                           / std::abs(_pulseIntervalClocks);

                if (maySkipPulses()) {  // ...its OK to ignore missed pulses
                    _lastPulseClocks += missed * _pulseIntervalClocks;
                    firePulsed(clocksToTime(_lastPulseClocks));

                } else {                // We must hit every pulse
                    _lastPulseClocks += _pulseIntervalClocks;
                    firePulsed(clocksToTime(_lastPulseClocks));

                    // See if we need to rewind to catch more pulses
                    if (missed > 1) // Uh oh...have to go back
                        _elapsedClocks = _lastPulseClocks;
                }
            }
        }
    }

    /**
     * Returns the value of the internal counter, in clock ticks.
     *
     * Note that this does not directly equate to real elapsed time, as the
     * frequency of the system's counter varies by platform, and time-warping
     * may be in effect.
     *
     * \return an integer number of clock ticks elapsed
     */
    clock_t elapsedClocks() const { return _elapsedClocks; }

    /**
     * Sets the value of the internal counter, in clock ticks. The actual value
     * that is set is constrained by the minimum and maximum bounds for the
     * timer. Setting the timer value in this way bypasses the pulsing
     * mechanism: it is as if we're skipping around in time, rather than just
     * traversing it really quickly. Do not pass go, do not collect $200.
     *
     * Note that this does not directly equate to real elapsed time, as the
     * frequency of the system's counter varies by platform, and time-warping
     * may be in effect.
     *
     * \param   the desired value of the internal counter, in clock ticks
     * \return  the actual value to which the internal counter is set
     */
    clock_t setElapsedClocks(clock_t clocks) {
        clock_t result = setInternalCounter(clocks); // Call the internal version
        _lastPulseClocks = result;  // Start pulsing from here
        return result;
    }

    /**
     * Retrieves the current time represented by this timer in scalar time
     * units.
     *
     * \return a scalar representing the current time elapsed on this timer
     */
    scalar_t time() const { return clocksToTime(elapsedClocks()); }

    /**
     * Sets the current time represented by this timer. The actual time that
     * is set depends on the minimum and maximum bounds on the timer and on
     * the quantization caused by conversion to the internal \c clock_t used
     * to represent time.
     *
     * This is equivalent to calling
     * \code setElapsedClocks(timeToClocks(t)); \endcode
     *
     * \param t the desired time to which to set the timer
     * \return  the actual time to which the timer is set
     */
    scalar_t setTime(scalar_arg_t t) {
        setElapsedClocks(timeToClocks(t));
        if (generateEvents) {
            scalar_t newTime = time();  // Get the new time
            fireSet(newTime);           // Tell all the listeners
            return newTime;             // Return the new time
        } else
            return time();              // Just return the new time
    }

    /**
     * Retrieves the current time represented by this timer in scalar time
     * units.
     *
     * This is an alias for \code time(). \endcode
     *
     * \return a scalar representing the current time elapsed on this timer
     */
    scalar_t operator()() const { return time(); }

    /**
     * Sets the current time represented by this timer.
     *
     * This is an alias for \code setTime(scalar_arg_t). \endcode
     *
     * \param t the desired time to which to set the timer
     * \return  the actual time to which the timer is set
     */
    scalar_t operator=(scalar_arg_t t) { return setTime(t); }

    /**
     * Returns the value in seconds corresponding to the given number of clock
     * ticks.
     *
     * Note that this function uses the value of timeWarpFactor() to transform
     * the result, meaning that the value this function returns may not reflect
     * real-world time values in seconds.
     *
     * \param   a value in system clock ticks
     * \return  the corresponding value in scalar time units
     */
    scalar_t clocksToTime(clock_t clocks) const {
        return clocks * timeWarpFactor() / _systemClockFrequency;
    }

    /**
     * Returns the nearest value in clock ticks corresponding to the given
     * value in scalar time units. Since the domain of scalar values is
     * normally the real numbers, and clock ticks are integral, this implies
     * that any use of this function will result in some sort of quantization
     * error. Furthermore, if the scalar's value in clock ticks exceeds the
     * legal range for clock_t's, this function will saturate (clamp to the
     * max or min clock_t value).
     *
     * This function simply does a straight conversion, and does not consider
     * the values of \c minimumTime() and \c maximumTime().
     *
     * Just like its sister function clocksToTime(clock_t), this function
     * uses the value of timeWarpFactor() to transform scalar time values,
     * and thus, the results may not reflect real-world time values in seconds.
     *
     * \param   a scalar time value
     * \return  the nearest number of clock ticks corresponding to this
     */
    clock_t timeToClocks(scalar_arg_t time) const {
        // See if this exceeds clock_t's abilities
        if (time > _maxRepresentableTime)
            return std::numeric_limits<clock_t>::max();
        else if (time < _minRepresentableTime)
            return std::numeric_limits<clock_t>::min();
        else
            return clock_t(time * _systemClockFrequency / timeWarpFactor());
    }

protected:
    // Used internally to set the value of elapsedClocks()
    clock_t setInternalCounter(clock_t clocks) {
        _elapsedClocks = clocks;        // Set our tentative new value
        enforceBoundaryConstraints();   // Make sure it's kosher
        return elapsedClocks();         // Tell 'em what we did
    }

    // Handles the response at the boundary values (i.e., loop, stop, bounce).
    void enforceBoundaryConstraints() {
        // First, check to see if we've overshot our upper limit
        if (_elapsedClocks > _maximumTimeClocks) {
            switch (_boundaryResponse) {
            case Stop:
                // Stop right at the boundary
                _elapsedClocks   = _maximumTimeClocks;
                _lastPulseClocks = _maximumTimeClocks;
                _running = false;

                // Tell all the listeners
                if (generateEvents)
                    fireStopped(time());
                break;

            case Bounce:
                // Reflect counter and last pulse across endpoint
                _elapsedClocks   = _maximumTimeClocks
                                 - (_elapsedClocks - _maximumTimeClocks);
                _lastPulseClocks = _maximumTimeClocks
                                 - (_lastPulseClocks - _maximumTimeClocks);
                _reversed = !_reversed;
                _pulseIntervalClocks = -_pulseIntervalClocks;

                // Tell all the listeners
                if (generateEvents)
                    fireReversed(time());
                break;

            case Loop:
                // Wrap counter and last pulse around endpoints
                _elapsedClocks   = _minimumTimeClocks
                                 + (_elapsedClocks - _maximumTimeClocks);
                _lastPulseClocks = _minimumTimeClocks
                                 + (_lastPulseClocks - _maximumTimeClocks);

                // Tell all the listeners
                if (generateEvents)
                    fireSet(time());
                break;

            default:
                INCA_ERROR( "Timer::enforceBoundaryConstraints(): "
                            << boundaryResponse() );
            }

        // Now, see if we've overshot the lower limit
        } else if (_elapsedClocks < _minimumTimeClocks) {
            switch (_boundaryResponse) {
            case Stop:
                // Stop right at the boundary
                _elapsedClocks = _minimumTimeClocks;
                _lastPulseClocks = _minimumTimeClocks;
                _running = false;

                // Tell all the listeners
                if (generateEvents)
                    fireStopped(time());
                break;

            case Bounce:
                // Reflect counter and last pulse across endpoint
                _elapsedClocks   = _minimumTimeClocks
                                 - (_elapsedClocks - _minimumTimeClocks);
                _lastPulseClocks = _minimumTimeClocks
                                 - (_lastPulseClocks - _lastPulseClocks);
                _reversed = !_reversed;
                _pulseIntervalClocks = -_pulseIntervalClocks;

                // Tell all the listeners
                if (generateEvents)
                    fireReversed(time());
                break;

            case Loop:
                // Wrap counter and last pulse around endpoints
                _elapsedClocks   = _maximumTimeClocks
                                 + (_elapsedClocks - _minimumTimeClocks);
                _lastPulseClocks = _maximumTimeClocks
                                 + (_lastPulseClocks - _minimumTimeClocks);

                // Tell all the listeners
                if (generateEvents)
                    fireSet(time());
                break;

            default:
                INCA_ERROR( "Timer::enforceBoundaryConstraints(): "
                            << boundaryResponse() );
            }
        }
    }

    clock_t _elapsedClocks;         // Our internal counter, representing time

    // Stuff for interfacing with the system
    clock_t _lastSystemClocks;      // The last time we talked to the OS
    clock_t _systemClockFrequency;  // The ticks/sec resolution of his counter

    // Stuff for sending out periodic pulses
    clock_t _pulseIntervalClocks;   // How many clocks to wait before pulsing
    clock_t _lastPulseClocks;       // The value of elapsedClocks() when we
                                    // last pulsed our listeners

    // Time-warping factor, which is multiplied by the actual time value
    scalar_t _timeWarpFactor;

    // Hard scalar-time constraints, imposed by the limits of clock_t
    scalar_t _maxRepresentableTime, _minRepresentableTime;

    // Soft timer constraints, representing the timer's valid range
    clock_t _minimumTimeClocks,     // The largest and smallest values we'll
            _maximumTimeClocks;     // allow the timer to have

    clock_t _initialTimeClocks;     // The value to load on a reset()


/*---------------------------------------------------------------------------*
 | Timer state control functions
 *---------------------------------------------------------------------------*/
public:
    /**
     * Stops the timer (if it is currently running) and resets it to the
     * initial value (supplied at construction time).
     */
    void reset() {
        stop();
        setElapsedClocks(_initialTimeClocks);
        if (generateEvents)     // Do we tell anyone about this?
            fireSet(time());
    }

    /**
     * Toggles the timer between the "running" and "not running" states. That
     * is, if the timer is currently running, it will be stopped, and vice
     * versa. This function does not reset the accumulated time on the timer,
     * so a timer may be toggled multiple times, just like an ordinary
     * stopwatch.
     *
     * \return  true if the timer is now running as a result of this call
     */
    bool toggleRunning() {
        if (! _running) {       // ...then we were just started
            _lastSystemClocks = getSystemClocks();
            if (generateEvents)     // Do we tell anyone about this?
                fireStarted(time());
        } else {                // ...then we were just stopped
            update();               // Catch up to "now"
            if (generateEvents)     // Do we tell anyone about this?
                fireStopped(time());
        }

        _running = ! _running;  // Switch states
        return running();
    }

    /**
     * Ensures that the timer is in the specified running state. If the timer
     * is already in the requested state, there is no effect and \c false is
     * returned. Otherwise, the running state is toggled and \c true is
     * returned.
     *
     * \return  true if the timer had to be toggled in order to assume this
     *          state
     */
    bool setRunning(bool run) {
        if (run == _running) {  // No state change. Go home.
            return false;
        } else {                // Transition to the opposite state
            toggleRunning();
            return true;            // a state change happened
        }
    }

    /**
     * Returns the current running state of the timer.
     *
     * \return \c true if the timer is currently running, or \c false otherwise
     */
    bool running() const { return _running; }

    /**
     * Starts the timer running. This function is equivalent to
     * \c setRunning(true).
     */
    void start() { setRunning(true); }

    /**
     * Stops (pauses) the timer. This function is equivalent to
     * \c setRunning(false).
     */
    void stop() { setRunning(false); }

    /**
     * Toggles the timer between the "reversed" and "not reversed" states. That
     * is, if the timer is currently reversed (i.e., headed toward negative
     * infinity), it will begin heading toward positive infinity, and vice
     * versa. This function does not reset the accumulated time on the timer,
     * so a timer may be toggled multiple times, just like an ordinary
     * stopwatch.
     *
     * \return  true if the timer is now reversed as a result of this call
     */
    void toggleReversed() {
        update();               // Make sure we're current!
        _reversed = ! _reversed;
        _pulseIntervalClocks = -_pulseIntervalClocks;

        if (generateEvents)     // Do we tell anyone about this?
            fireReversed(time());
        return reversed();
    }

    bool setReversed(bool rev) {
        if (rev == _reversed) { // No state change. Go home.
            return false;
        } else {                // Transition to the opposite state
            toggleReversed();
            return true;    // a state change happened
        }
    }

    /**
     * Returns whether or not the timer is running in reversed mode.
     *
     * \return \c true if the timer is currently reversed, or \c false otherwise
     */
    bool reversed() const { return _reversed; }

    BoundaryResponse boundaryResponse() const { return _boundaryResponse; }
    void setBoundaryResponse(BoundaryResponse r) { _boundaryResponse = r; }
    bool maySkipPulses() const { return _maySkipPulses; }
    void setMaySkipPulses(bool s) { _maySkipPulses = s; }

protected:
    // Timer state flags
    bool _running, _reversed, _maySkipPulses;
    BoundaryResponse _boundaryResponse;


/*---------------------------------------------------------------------------*
 | Timer pulse interval, warping, and bounds
 *---------------------------------------------------------------------------*/
public:
    scalar_t pulseInterval() const { return clocksToTime(_pulseIntervalClocks); }

    void setPulseInterval(scalar_arg_t interval) {
        // If this would be negative, throw a fit
        if (interval < scalar_t(0)) {
            INCA_WARNING( "Timer::setPulseInterval(" << interval << "): "
                          "Ignoring illegal negative pulse interval" );

        // Otherwise, do it
        } else {
           _pulseIntervalClocks = timeToClocks(interval);
        }
    }

    scalar_t timeWarpFactor() const { return _timeWarpFactor; }

    void setTimeWarpFactor(scalar_arg_t warp) {
        // If this would be non-positive, throw a fit
        if (warp <= scalar_t(0)) {
            INCA_WARNING( "Timer::setTimeWarpFactor(" << warp << "): "
                          "Ignoring illegal non-positive time warp factor" );

        // Otherwise, do it
        } else {
            _timeWarpFactor = warp;

            // The limits imposed by clock_t have now changed, so recalculate
            _minRepresentableTime = clocksToTime(std::numeric_limits<clock_t>::min());
            _maxRepresentableTime = clocksToTime(std::numeric_limits<clock_t>::max());
        }
    }

    scalar_t minimumTime() const { return clocksToTime(_minimumTimeClocks); }

    void setMinimumTime(scalar_arg_t min) {
        clock_t minClocks = timeToClocks(min);

        // If this would cause an invalid range, throw a fit
        if (minClocks >= _maximumTimeClocks) {
            INCA_WARNING( "Timer::setMinimumTime(" << min << "): Setting new "
                          << "minimum would result in invalid bounds ["
                          << min << ", " << clocksToTime(_maximumTimeClocks)
                          << "] -- ignoring" );

        // Otherwise, do it, and fix the damage
        } else {
            _minimumTimeClocks = minClocks;
            enforceBoundaryConstraints();   // Make elapsedClocks obedient
        }
    }

    scalar_t maximumTime() const { return clocksToTime(_maximumTimeClocks); }

    void setMaximumTime(scalar_arg_t max) {
        clock_t maxClocks = timeToClocks(max);

        // If this would cause an invalid range, throw a fit
        if (maxClocks <= _minimumTimeClocks) {
            LOG_WARNING( "Timer::setMaximumTime(" << max << "): Setting new "
                         << "maximum would result in invalid bounds ["
                         << clocksToTime(_minimumTimeClocks) << ", " << max
                         << "] -- ignoring" );

        // Otherwise, do it, and fix the damage
        } else {
            _maximumTimeClocks = maxClocks;
            enforceBoundaryConstraints();   // Make elapsedClocks obedient
        }
    }
};


#endif
