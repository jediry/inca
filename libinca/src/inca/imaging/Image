/* -*- C++ -*-
 *
 * File: Image
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2002, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      The Image template class is conceptually a rectangular buffer of pixels,
 *      and contains functions for accessing and manipulating the pixels in
 *      the image.
 */

#ifndef INCA_IMAGING_IMAGE
#define INCA_IMAGING_IMAGE

// Import system configuration
#include <inca/inca-common.h>


// This is part of the Inca imaging library
namespace inca {
    namespace imaging {
        // Forward declarations
        template <typename Color> class Image;

        // What do we do if we try to access a pixel out of bounds?
        enum BorderMode {
            CLAMP,      // Use the nearest edge pixel
            WRAP,       // Wrap around to the opposite side
            MIRROR,     // Mirror back into the image
            BACKGROUND, // Solid background color
        };
    };
};


template <typename Color>
class inca::imaging::Image {
public:
    // Template typedefs
    typedef multi_array<Color, 2> PixelGrid;

    Image(unsigned int w, unsigned int h, BorderMode mode = CLAMP)
        : pixelGrid(new PixelGrid(w, h)), borderMode(mode),
          imageWidth(w), imageHeight(h) { }

    unsigned int width() const { return imageWidth; }
    unsigned int height() const { return imageHeight; }

    PixelGrid & pixels() { return *pixelGrid; }
    const PixelGrid & pixels() const { return *pixelGrid; }

    Color & operator()(int x, int y) {
        return (*pixelGrid)(x, y);
    }

    const Color & operator()(int x, int y) const {
        // Handle an out-of-bounds X coordinate
        if (x < 0)
            switch(borderMode) {
                case CLAMP:         x = 0;
                case WRAP:          x = imageWidth - x;
                case MIRROR:        x = -x;
                case BACKGROUND:    return backgroundColor; // We're done!
            }
        else if (x >= imageWidth)
            switch(borderMode) {
                case CLAMP:         x = imageWidth - 1;
                case WRAP:          x = x - imageWidth;
                case MIRROR:        x = 2 * imageWidth - x;
                case BACKGROUND:    return backgroundColor; // We're done!
            }

        // Handle an out-of-bounds X coordinate
        if (y < 0)
            switch(borderMode) {
                case CLAMP:         y = 0;
                case WRAP:          y = imageHeight - y;
                case MIRROR:        y = -y;
                case BACKGROUND:    return backgroundColor; // We're done!
            }
        else if (y >= imageHeight)
            switch(borderMode) {
                case CLAMP:         y = imageHeight - 1;
                case WRAP:          y = y - imageHeight;
                case MIRROR:        y = 2 * imageHeight - y;
                case BACKGROUND:    return backgroundColor; // We're done!
            }
        
        // If we haven't already returned, lookup our pxel and go back
        return (*pixelGrid)(x, y);
    }

protected:
    scoped_ptr<PixelGrid> pixelGrid;
    unsigned int imageWidth, imageHeight;
    BorderMode borderMode;
    Color backgroundColor;
};

#endif
