/* -*- C++ -*-
 *
 * File: MIPMap
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2002, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      The MIPMap template class holds an Image, and a series of progressively
 *      smaller, filtered versions of the Image. It provides a 3D-addressable
 *      structure allowing a pixel color to be interpolated along u, v, and d
 *      dimensions, where u & v are texture coordinates in [0, 1] and d is
 *      the mipmap depth, in [0, log2(??)].
 */

#ifndef INCA_IMAGING_MIPMAP
#define INCA_IMAGING_MIPMAP

// This is part of the Inca imaging library
namespace Inca {
    namespace Imaging {
        // Forward declarations
        template <typename Color, class Filter> class MIPMap;
    };
};


template <typename Color, class Filter>
class Inca::Imaging::MIPMap {
public:
    // Template typedefs
    typedef typename Color::scalar_t     scalar_t;
    typedef typename Color::scalar_arg_t scalar_arg_t;
    typedef Image<Color>        Image;
    typedef shared_ptr<Image>   ImagePtr;
    typedef vector<ImagePtr>    ImagePtrArray;


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    MIPMap(ImagePtr i) {
        // Store a pointer to the original image
        levels.push_back(i);

        // Create the successively smaller versions of the image
        unsigned int width = i->width(),
                     height = i->height(),
                     minExtent = width < height ? width : height,
                     filterWidth = 1;
        while (minExtent > 1) {
            // Figure out our next level's dimensions
            width >>= 1; height >>= 1;
            minExtent = width < height ? width : height;
            filterWidth <<= 1;

            // Create a smaller image
            levels.push_back(ImagePtr(new Image(width, height)));

            // Make a filter to scale the thing
            Filter filter(filterWidth, filterWidth);

            // Downsample the master image into this one
            filter.apply(*levels.back(), *levels.front());

            cerr << "MIPMap level " << (levels.size() - 1) << ": "
                 << width << 'x' << height << " (" << filterWidth << ')' << endl;
        }
    }


/*---------------------------------------------------------------------------*
 | Image/pixel-data access functions
 *---------------------------------------------------------------------------*/
public:
    // Lookup/interpolate a color given u, v, and d
    Color operator()(scalar_arg_t u, scalar_arg_t v, scalar_arg_t d) const {
        return Color();
    }

    // Retrieve a level (filtered subimage) from the MIPMap
    ImagePtr operator[](unsigned int d) { return levels[d]; }
    const ImagePtr operator[](unsigned int d) const { return levels[d]; }
    unsigned int size() const { return levels.size(); }

protected:
    ImagePtrArray levels;
};

#endif
