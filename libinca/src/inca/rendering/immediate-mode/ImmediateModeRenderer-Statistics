/** -*- C++ -*-
 *
 * File: ImmediateModeRenderer-Statistics
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file defines the TextureUnit inner class belonging to
 *      ImmediateModeRenderer. A TextureUnit directly represents a
 *      hardware-accelerated texture.
 *
 *      This file is not meant to be used directly, but is included by
 *      the main ImmediateModeRenderer header file.
 */


#ifndef INCA_RENDERING_IMMEDIATE_MODE_RENDERER_STATISTICS
#define INCA_RENDERING_IMMEDIATE_MODE_RENDERER_STATISTICS

// Import Timer definition
#include <inca/util/Timer>


RENDERER_TEMPLATE
class RENDERER::Statistics : public RENDERER::Component {
public:
    // Timer typedefs
    typedef inca::Timer<timer_t>    Timer;
    static const SizeType PRIMITIVE_TYPE_COUNT = ALL_PRIMITIVE_TYPES;
    static const SizeType RENDER_PASS_COUNT    = ALL_RENDER_PASSES;

    // Constructor
    Statistics() { reset(); }


/*---------------------------------------------------------------------------*
 | Modifier functions
 *---------------------------------------------------------------------------*/
    void reset() {
        // Zero our counters
        _frameCount = 0;
        _vertexCount = 0;
        for (IndexType i = 0; i < PRIMITIVE_TYPE_COUNT; i++) {
            _vertexTypeCounts[i];
            for (IndexType j = 0; j < RENDER_PASS_COUNT; j++)
                _vertexTypePassCounts[i][j];
        }

        // Zero our timers
        _renderTime.reset();
        _realTime.reset();
        for (IndexType i = 0; i < RENDER_PASS_COUNT; i++)
            _renderPassTimes[i].reset();

        // Start the real-time timer going
        _realTime.start();
    }

    void beginFrame() {
        _frameCount++;
        _renderTime.start();
    }
    void endFrame() {
        _renderTime.stop();
    }

    void beginRenderPass(IndexType pass) {
        if (boundsCheck) {
            if (pass < 0 || pass >= RENDER_PASS_COUNT) {
                cerr << "RenderStatistics::beginRenderPass(" << pass
                     << "): render pass " << pass << " out of range\n";
                return;
            }
        }
        _renderPassTimes[pass].start();
    }
    void endRenderPass(IndexType pass) {
        if (boundsCheck) {
            if (pass < 0 || pass >= RENDER_PASS_COUNT) {
                cerr << "RenderStatistics::endRenderPass(" << pass
                     << "): render pass " << pass << " out of range\n";
                return;
            }
        }
        _renderPassTimes[pass].stop();
    }

    void vertexRendered(IndexType type, IndexType pass) {
        if (boundsCheck) {
            if (type < 0 || type >= PRIMITIVE_TYPE_COUNT) {
                cerr << "RenderStatistics::vertexRendered("
                     << type << ", " << pass
                     << "): primitive type " << type << " out of range\n";
                return;
            }
            if (pass < 0 || pass >= RENDER_PASS_COUNT) {
                cerr << "RenderStatistics::vertexRendered("
                     << type << ", " << pass
                     << "): render pass " << pass << " out of range\n";
                return;
            }
        }
        _vertexTypeCounts[type]++;
        _vertexTypePassCounts[type][pass]++;
        _vertexCount++;
    }


/*---------------------------------------------------------------------------*
 | Query functions
 *---------------------------------------------------------------------------*/
    SizeType frameCount() const {
        return _frameCount;
    }

    SizeType primitiveCount() const {
        return _vertexCount;
    }

    SizeType primitiveCount(IndexType type) const {
        if (boundsCheck) {
            if (type < 0 || type >= PRIMITIVE_TYPE_COUNT) {
                cerr << "RenderStatistics::primitiveCount(" << type
                     << "): primitive type " << type << " out of range\n";
                return 0;
            }
        } else {
            return _vertexTypeCounts[p];
        }
    }

    SizeType primitiveCount(IndexType type, IndexType pass) const {
        if (boundsCheck) {
            if (type < 0 || type >= PRIMITIVE_TYPE_COUNT) {
                cerr << "RenderStatistics::primitiveCount("
                     << type << ", " << pass
                     << "): primitive type " << type << " out of range\n";
                return 0;
            }
            if (pass < 0 || pass >= RENDER_PASS_COUNT) {
                cerr << "RenderStatistics::primitiveCount("
                     << type << ", " << pass
                     << "): render pass " << pass << " out of range\n";
                return 0;
            }
        } else {
            return _vertexTypePassCounts[type][pass];
        }
    }

    timer_t realTime() const { return _realTime.getTime(); }
    timer_t renderTime() const { return _renderTime.getTime(); }
    timer_t renderTime(IndexType pass) const {
        if (boundsCheck) {
            if (pass < 0 || pass >= RENDER_PASS_COUNT) {
                cerr << "RenderStatistics::renderTime(" << pass
                     << "): render pass " << pass << " out of range\n";
                return timer_t(0.0);
            }
        }
        return _renderPassTimes[pass].getTime();
    }

    timer_t framesPerSecond() const {
        timer_t time = _realTime.getTime();
        if (time == timer_t(0.0))   return timer_t(0.0);
        else                        return _frameCount / time;
    }

protected:
    // Number of frames rendered
    SizeType _frameCount;

    // Accounting of rendered primitives
    SizeType _vertexCount;
    SizeType _vertexTypeCounts[PRIMITIVE_TYPE_COUNT];
    SizeType _vertexTypePassCounts[PRIMITIVE_TYPE_COUNT][RENDER_PASS_COUNT];

    // Timers for keeping track of where our render time is spent
    Timer _realTime;                        // Time since last call to reset()
    Timer _renderTime;                      // Time spent rendering (per se)
    Timer _renderPassTimes[RENDER_PASS_COUNT];  // Time per render pass
};

#endif
