/** -*- C++ -*-
 *
 * File: ImmediateModeRenderer-Rasterizer
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file defines the Rasterizer inner class belonging to
 *      ImmediateModeRenderer. The Rasterizer represents the renderer's
 *      rasterization-related state variables.
 *
 *      This file is not meant to be used directly, but is included by
 *      the main ImmediateModeRenderer header file.
 */

#ifndef INCA_RENDERING_IMMEDIATE_MODE_RENDERER_RASTERIZER
#define INCA_RENDERING_IMMEDIATE_MODE_RENDERER_RASTERIZER


RENDERER_TEMPLATE
class RENDERER::Rasterizer : public RENDERER::Component {
/*---------------------------------------------------------------------------*
 | Constructors & Destructor
 *---------------------------------------------------------------------------*/
public:
    // Constructor
    Rasterizer(RENDERER &r, id_t myID);

    // Destructor
    ~Rasterizer();


/*---------------------------------------------------------------------------*
 | Rasterization mode/feature toggles
 *---------------------------------------------------------------------------*/
public:
    // Z-buffering
    bool isDepthBufferingEnabled() const;
    void enableDepthBuffering(bool enabled);

    // Alpha blending
    bool isAlphaBlendingEnabled() const;
    void enableAlphaBlending(bool enabled);

    // Backface (or frontface culling)
    bool isFaceCullingEnabled() const;
    void enableFaceCulling(bool enabled);

    // Illumination
    bool isLightingEnabled() const;
    void enabledLighting(bool enabled);

    // Shading mode
    ShadingMode shadingMode() const;
    void setShadingMode(ShadingMode mode);

    // Point antialiasing
    bool isPointSmoothingEnabled() const;
    void enablePointSmoothing(bool enabled);

    // Line antialiasing
    bool isLineSmoothingEnabled() const;
    void enableLineSmoothing(bool enabled);

    // Polygon antialiasing
    bool isPolygonSmoothingEnabled() const;
    void enablePolygonSmoothing(bool enabled);

    
/*---------------------------------------------------------------------------*
 | Rasterization parameter functions
 *---------------------------------------------------------------------------*/
public:
    // Current background color
    Color backgroundColor() const;
    void setBackgroundColor(const Color &c);

    // Current point diameter
    float pointDiameter() const;
    void setPointDiameter(float size);

    // Current line width
    float lineWidth() const;
    void setLineWidth(float width);

    // Current drawing color
    Color drawingColor() const;
    template <typename scalar, class colorspace>
        void setColor(const math::Color<scalar, colorspace> &c);

    // Current vertex normal
    Normal normal() const;
    template <typename scalar, size_t dim>
        void setNormal(const math::Vector<scalar, dim> &n);

    // Current texture coordinates
    TexCoord texCoords() const;
    template <typename scalar, size_t dim>
        void setTexCoords(const math::Point<scalar, dim> &t);

    // Current edge-of-primitive flag
    bool edgeFlag() const;
    void setEdgeFlag(bool isEdge);


/*---------------------------------------------------------------------------*
 | Vertex-array functions
 *---------------------------------------------------------------------------*/
public:
    // Vertex array data
    template <typename vertex_t>
        void setVertexArray(const VertexArray<vertex_t> &va);
    template <typename vertex_t>
        void setVertexArray(vertex_t const *va, size_t stride = 0);

    // Normal array data
    template <typename normal_t>
        void setNormalArray(const NormalArray<normal_t> &na);
    template <typename normal_t>
        void setNormalArray(normal_t const *na, size_t stride = 0);

    // Texture coordinate array data
    template <typename tex_coord_t>
        void setTexCoordArray(const TexCoordArray<tex_coord_t> &tca);
    template <typename tex_coord_t>
        void setTexCoordArray(tex_coord_t const *tca, size_t stride = 0);

    // Color array data
    template <typename color_t>
        void setColorArray(const ColorArray<color_t> &ca);
    template <typename color_t>
        void setColorArray(color_t const *ca, size_t stride = 0);

    // Edge flag array data
    template <typename edge_flag_t>
        void setEdgeFlagArray(const EdgeFlagArray<edge_flag_t> &efa);
    void setEdgeFlagArray(bool const *efa, size_t stride = 0);


/*---------------------------------------------------------------------------*
 | Primitive rendering functions
 *---------------------------------------------------------------------------*/
public:
    // Render a pre-built, batch primitive
    template <typename vertex_t, typename normal_t, typename tex_coord_t,
              typename color_t, typename edge_flag_t>
    void renderPrimitive(const Primitive<vertex_t, normal_t, tex_coord_t,
                                         color_t, edge_flag_t> &p) {
        // Set up the vertex arrays
        setVertexArray(p);
        setNormalArray(p);
        setTexCoordArray(p);
        setColorArray(p);
        setEdgeFlagArray(p);

        // Render the primitive
        // FIXME: Implement
    }

    // Start/end rendering a geometric primitive
    void beginPrimitive(PrimitiveType type);
    void endPrimitive();

    // Create a vertex at a point
    template <typename scalar, size_t dim>
        void vertexAt(const math::Point<scalar, dim> &p);

    // Create a vertex using the data in the currently enabled arrays
    void vertexAt(index_t index);
};

#endif
