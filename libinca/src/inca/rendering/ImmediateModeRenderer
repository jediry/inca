/** -*- C++ -*-
 *
 * File: ImmediateModeRenderer
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file declares the classes and functions for rendering objects in
 *      "immediate mode". In immediate mode, primitives (points, lines, curves,
 *      bezier patches, etc.) are rendered one-at-a-time using a local lighting
 *      model (as opposed to a global lighting model, such as in raytracing,
 *      which considers the entire scene as a whole for the purpose of
 *      calculating the lighting. Because an immediate-mode renderer can
 *      deal with primitives independently of one another, the renderer can be
 *      designed as a state-machine, such that the programmer sets the
 *      renderer's "current" attributes (transformation matrix stack, color,
 *      lighting mode, etc.) and then draws the primitives using the current
 *      state. DirectX and OpenGL are two examples of immediate mode
 *      rendering APIs.
 *
 *      Because of the sheer volume of code that makes up this structure and
 *      its subunits, it has been split up into logical chunks and implemented
 *      in separate files, which files are then included at the end of this
 *      one (which is the main file, in case you were wondering).
 *
 * Not implemented:
 *      Stipple, color-index mode, culling, poly offset, poly mode (f/b)
 */

#ifndef INCA_RENDERING_IMMEDIATE_MODE_RENDERER
#define INCA_RENDERING_IMMEDIATE_MODE_RENDERER

// Import system configuration
#include <inca/inca-common.h>

// This is part of the Inca rendering subsystem
namespace inca {
    namespace rendering {
        // Forward declarations
        template <class APITraits> class ImmediateModeRenderer;
    };
};


// Import superclass definition
#include "Renderer.hpp"

// Import rendering type definitions
#include "types.hpp"
#include "Primitive"

// Import types from other Inca libraries
#include <inca/math.hpp>


// Import container definitions
#include <vector>
#include <boost/array.hpp>

    //PickingProjection
    //OrthographicProjection
    //PerspectiveProjection
    //ScreenspaceProjection


// Make some REALLY long names shorter
#define RENDERER_TEMPLATE template <class APITraits>
#define RENDERER inca::rendering::ImmediateModeRenderer<APITraits>


RENDERER_TEMPLATE class RENDERER {
/*---------------------------------------------------------------------------*
 | Type definitions
 *---------------------------------------------------------------------------*/
public:
    // Geometric type definitions
    typedef typename APITraits::geometry_t geometry_t;
    INCA_MATH_LINALG_TYPES_CUSTOM(geometry_t, 2, /* */, 2D);
    INCA_MATH_LINALG_TYPES_CUSTOM(geometry_t, 3, /* */, 3D);
    typedef Quaternion3D                Quaternion;
    typedef typename APITraits::Matrix  Matrix;

    // Color type definitions
    typedef typename APITraits::color_t color_t;
    typedef typename APITraits::Color   Color;

    // Texture coordinate type definitions
    typedef typename APITraits::tex_coord_t tex_coord_t;
    
    // Timer type definitions
    typedef typename APITraits::timer_t timer_t;

    // Screenspace type definitions
    typedef typename APITraits::Pixel       Pixel;
    typedef typename APITraits::Dimension   Dimension;

    // Import world object types
    typedef world::Transform Transform;


protected:
    // Inner class that serves as the base class for the other components
    class Component;


public:
    // The following substructures are implemented in separate files,
    // for the sake of keeping this code readable, and are included
    // at the end of this file

    // Inner class keeping track of the performance of the renderer
    class Statistics;

    // Inner class representing a screenspace viewport
    class Viewport;

    // Inner classes representing graphics hardware resources
    class MatrixStack;  // A hardware matrix stack
    class TextureUnit;  // A hardware texture unit
    class LightingUnit; // A hardware lighting unit

    // Inner classes representing hardware raster buffers
    template <typename element_t> class Buffer;
    typedef Buffer<Color>       ColorBuffer;
    typedef Buffer<geometry_t>  ScalarBuffer;
    typedef Buffer<Color>       AccumulationBuffer;

    // Property caching mechanism
    template <typename T>
    class CacheEntry {
    public:
        // Constructor
        CacheEntry(const T & val = T(), bool isValid = false)
            : value(val), valid(isValid) { }

        T value;    // The cached value
        bool valid; // Is this cache entry current with the hardware?
    };

    // Container type definitions
    typedef std::vector<MatrixStack>    MatrixStackList;
    typedef std::vector<TextureUnit>    TextureUnitList;
    typedef std::vector<LightingUnit>   LightingUnitList;
    typedef std::vector<ColorBuffer>    ColorBufferList;
    typedef std::vector<ScalarBuffer>   ScalarBufferList;
    typedef std::vector<Statistics>     StatisticsList;
    typedef boost::array<CacheEntry<bool>,  APITraits::numBoolProperties>
        BoolPropertyCache;
    typedef boost::array<CacheEntry<int>,   APITraits::numIntProperties>
        IntPropertyCache;
    typedef boost::array<CacheEntry<float>, APITraits::numFloatProperties>
        FloatPropertyCache;
    typedef boost::array<CacheEntry<double>,APITraits::numDoubleProperties>
        DoublePropertyCache;
    typedef boost::array<CacheEntry<Color>, APITraits::numColorProperties>
        ColorPropertyCache;

    // We're all buddy-buddy with our sub-objects
    friend Component;
    friend Statistics;
    friend Viewport;
    friend MatrixStack;
    friend TextureUnit;
    friend LightingUnit;
    friend ColorBuffer;
    friend ScalarBuffer;
    friend AccumulationBuffer;


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    // Constructor
    ImmediateModeRenderer();


/*---------------------------------------------------------------------------*
 | Renderer sub-objects
 *---------------------------------------------------------------------------*/
public:
    // Access to the drawable screen viewport
    Viewport & viewport();

    // Access to available hardware matrix stacks
    MatrixStack & projectionMatrix();
    MatrixStack & viewMatrix();
    MatrixStack & worldMatrix();
    MatrixStack & colorMatrix();

    // Access to available hardware buffers
    ColorBuffer & auxillaryBuffer(index_t i);
    ColorBuffer & stencilBuffer();
    ScalarBuffer & depthBuffer();
    AccumulationBuffer & accumulationBuffer();

    // Performance & statistics
    Statistics & frameStatistics();
    Statistics & cumulativeStatistics();

protected:
    // Renderer sub-objects
    MatrixStackList     _matrixStacks;
    Viewport            _viewport;
    TextureUnitList     _textureUnits;
    LightingUnitList    _lightingUnits;
    ColorBufferList     _colorBuffers;
    ScalarBufferList    _scalarBuffers;
    StatisticsList      _statistics;

    // Property caches
    mutable BoolPropertyCache   boolPropertyCache;
    mutable IntPropertyCache    intPropertyCache;
    mutable FloatPropertyCache  floatPropertyCache;
    mutable DoublePropertyCache doublePropertyCache;
    mutable ColorPropertyCache  colorPropertyCache;


/*---------------------------------------------------------------------------*
 | Coordinate space transformation functions
 *---------------------------------------------------------------------------*/
public:
    // Transform between world and local coordinate spaces
    Point3D worldToLocal(const Point3D &world) const {
        return viewTransformation.transform(world);
    }
    Vector3D worldToLocal(const Vector3D &world) const {
        return viewTransformation.transform(world);
    }
    Point3D localToWorld(const Point3D &local) const {
        return viewTransformation.untransform(local);
    }
    Vector3D localToWorld(const Vector3D &local) const {
        return viewTransformation.untransform(local);
    }

    // Transform between world and screen coordinate spaces
    Point3D worldToScreen(const Point3D &world) const {
        return  viewport.transform(
                    projectionTransformation.transform(
                        viewTransformation.transform(world)
                    )
                );
    }
    Point3D screenToWorld(const Point3D &screen) const {
        return  viewTransformation.untransform(
                    projectionTransformation.untransform(
                        viewport.untransform(screen)
                    )
                );
    }


/*---------------------------------------------------------------------------*
 | Rendering-state control functions
 *---------------------------------------------------------------------------*/
public:
    // Background color
    Color backgroundColor() const;
    void setBackgroundColor(const Color &c);

    // Fragment depth-test
    bool isDepthBufferingEnabled() const;
    void enableDepthBuffering(bool enabled);

    float pointDiameter() const;
    void setPointDiameter(float size);

    float lineWidth() const;
    void setLineWidth(float width);

    bool isPointSmoothingEnabled() const;
    void enablePointSmoothing(bool enabled);

    bool isLineSmoothingEnabled() const;
    void enableLineSmoothing(bool enabled);

    bool isBlendingEnabled() const;
    void enableBlending(bool enabled);

    bool isLightingEnabled() const;
    void enabledLighting(bool enabled);

    void setShadingMode(ShadingMode mode);


/*---------------------------------------------------------------------------*
 | Primitive rendering functions
 *---------------------------------------------------------------------------*/
public:
    // Start/end rendering a geometric primitive
    void beginPrimitive(PrimitiveType type);
    void endPrimitive();

    // Create a vertex at a point
    template <typename scalar, size_t dim>
    void vertexAt(const math::Point<scalar, dim> &p);

    // Create a vertex using the data in the currently enabled arrays
    void vertexAt(index_t index);

    // Current drawing color
    template <typename scalar, class colorspace>
    void setColor(const math::Color<scalar, colorspace> &c);

    // Current vertex normal
    template <typename scalar, size_t dim>
    void setNormal(const math::Vector<scalar, dim> &n);

    // Current texture coordinates
    template <typename scalar, size_t dim>
    void setTexCoords(const math::Point<scalar, dim> &t);

    // Current edge-of-primitive flag
    void setEdgeFlag(bool isEdge);


    // Vertex array data
    template <typename vertex_t>
    void setVertexArray(const VertexArray<vertex_t> &va);
    template <typename vertex_t>
    void setVertexArray(vertex_t const *va, size_t stride = 0);

    // Normal array data
    template <typename normal_t>
    void setNormalArray(const NormalArray<normal_t> &na);
    template <typename normal_t>
    void setNormalArray(normal_t const *na, size_t stride = 0);

    // Texture coordinate array data
    template <typename tex_coord_t>
    void setTexCoordArray(const TexCoordArray<tex_coord_t> &tca);
    template <typename tex_coord_t>
    void setTexCoordArray(tex_coord_t const *tca, size_t stride = 0);

    // Color array data
    template <typename color_t>
    void setColorArray(const ColorArray<color_t> &ca);
    template <typename color_t>
    void setColorArray(color_t const *ca, size_t stride = 0);

    // Edge flag array data
    template <typename edge_flag_t>
    void setEdgeFlagArray(const EdgeFlagArray<edge_flag_t> &efa);
    void setEdgeFlagArray(bool const *efa, size_t stride = 0);

    // Render a pre-built, batch primitive
    template <typename vertex_t, typename normal_t, typename tex_coord_t,
              typename color_t, typename edge_flag_t>
    void renderPrimitive(const Primitive<vertex_t, normal_t, tex_coord_t,
                                         color_t, edge_flag_t> &p) {
        // Set up the vertex arrays
        setVertexArray(p);
        setNormalArray(p);
        setTexCoordArray(p);
        setColorArray(p);
        setEdgeFlagArray(p);

        // Render the primitive
        // FIXME: Implement
    }


/*---------------------------------------------------------------------------*
 | Selection functions
 *---------------------------------------------------------------------------*/
public:
    void setSelectionID(id_t id) const;
    void pushSelectionID(id_t id) const;
    void popSelectionID() const;
    void getSelectedIDs(world::SelectionSet &s) const;

#if 0
    // Start/end the rendering of a frame
    void beginFrame() {
        frameStatistics.reset();
        frameStatistics.beginFrame();
        cumulativeStatistics.beginFrame();
    }
    void endFrame() {
        frameStatistics.endFrame();
        cumulativeStatistics.endFrame();
    }

    void beginRenderPass(RenderPass pass) {
        // Begin timing this render pass
        frameStatistics.beginRenderPass(pass);
        cumulativeStatistics.beginRenderPass(pass);

        switch (pass) {
        case Opacity:
            api::set_fill_mode(Filled);         // Draw filled polyons
            api::enable_alpha_blending(false);  // No transparency
            api::lock_z_buffer(false);          // Normal Z-buffer use
            api::enable_culling(true);          // Cull back-faces
            break;
        case Wireframe:
            api::set_fill_mode(Outlined);       // Draw wireframe
            api::enable_alpha_blending(false);  // No transparency
            api::lock_z_buffer(false);          // Normal Z-buffer use
            api::enable_culling(false);         // Don't cull faces
            break;
        case Transparency:
            api::set_fill_mode(Filled);         // Draw filled polygons
            api::enable_alpha_blending(true);   // Enable transparency
            api::lock_z_buffer(true);           // Don't update Z-buffer
            api::enable_culling(false);         // Don't cull faces
            break;
        case Selection:
            api::enable_selection_mode(true);   // Enter selection mode
            api::clear_selection_id_stack();    // Start from scratch
            break;
        default:
            logger << "IMR::initializeRenderPass(" << pass << "): not supported";
            logger.warning();
        }
        // Keep track of our state
        _currentRenderPass = pass;
    }

    void endRenderPass() {
        switch (_currentRenderPass) {
        case Selection:
            api::enable_selection_mode(false);  // Finish out the selection
            break;
        }
        frameStatistics.endRenderPass(_currentRenderPass);
        cumulativeStatistics.endRenderPass(_currentRenderPass);
    }


protected:
    RenderPass    _currentRenderPass;
    PrimitiveType _currentPrimitiveType;
#endif
};


// Import implementation of renderer sub-objects
#include "ImmediateModeRenderer-Statistics"
#include "ImmediateModeRenderer-Viewport"
#include "ImmediateModeRenderer-MatrixStack"
#include "ImmediateModeRenderer-LightingUnit"
#include "ImmediateModeRenderer-TextureUnit"
#include "ImmediateModeRenderer-Buffer"

// Clean up the preprocessor namespace
#undef RENDERER_TEMPLATE
#undef RENDERER

#endif