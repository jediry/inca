/** -*- C++ -*-
 *
 * File: ImmediateModeRenderer
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file declares the classes and functions for rendering objects in
 *      "immediate mode". In immediate mode, primitives (points, lines, curves,
 *      bezier patches, etc.) are rendered one-at-a-time using a local lighting
 *      model (as opposed to a global lighting model, such as in raytracing,
 *      which considers the entire scene as a whole for the purpose of
 *      calculating the lighting. Because an immediate-mode renderer can
 *      deal with primitives independent of each other, the renderer can be
 *      designed as a state-machine, such that the programmer sets the
 *      renderer's "current" attributes (transformation matrix stack, color,
 *      lighting mode, etc.) and then draws the primitives using the current
 *      state. DirectX and OpenGL are two examples of
 *      immediate mode rendering APIs.
 *
 *      The OpenGLRenderer is a subclass of Renderer designed to
 *      offer a higher-level interface around a low-level rendering API like
 *      OpenGL. It provides wrapper functions allowing the low-level API's
 *      functions to be invoked with the corresponding Inca::World objects and
 *      the rendering primitives declared in this file.
 *
 *      OpenGLRenderer can be used in either of two modes:
 *      true-immediate or semi-immediate. In true-immediate mode, the renderer
 *      behaves in the same manner as the underlying low-level API. To use the
 *      renderer in this way, simply call the high-level functions
 *      in the same order as you would have called the corresponding low-level
 *      API functions. In this way, it is possible to create a
 *      rendering-system-independent application, and to switch between
 *      multiple renderers as desired.
 *
 *      In semi-immediate mode, the renderer attempts to optimize the rendering
 *      process by reordering the necessary operations. For example, since
 *      loading and switching textures may be a computationally expensive
 *      operation, the renderer will collate sets of primitives using the
 *      same texture and draw them consecutively, thus saving the expense of
 *      making that texture "current" multiple times. This could be done
 *      manually in true-immediate mode, but when materials are shared between
 *      different objects, this might get messy.
 *      
 *      
 */

#ifndef INCA_RENDERING_IMMEDIATE_MODE_RENDERER
#define INCA_RENDERING_IMMEDIATE_MODE_RENDERER

// Import system configuration
#include <inca/inca-common.h>


// This is part of the Inca rendering subsystem
namespace inca {
    namespace rendering {
        // Forward declarations
        template <typename RenderingAPI> class ImmediateModeRenderer;
    };
};


// Import superclass definition
#include "Renderer.hpp"

// Import the traits template that interfaces with the underlying API
#include "immediate_mode_rendering_api"

// Import our statistics keeper
#include "RenderStatistics"

// Import rendering type definitions
#include "types.hpp"

// Import types from other Inca libraries
#include <inca/math.hpp>
#include <inca/imaging.hpp>


template <typename RenderingAPI>
class inca::rendering::ImmediateModeRenderer : public Renderer {
public:
    // Implementation traits typedef
    typedef immediate_mode_rendering_api<RenderingAPI> api;

    // Rendering statistics counter defintion
    typedef RenderStatistics<float, ALL_PRIMITIVE_TYPES, ALL_RENDER_PASSES>
        RenderStatistics;

    // Geometric type definitions
    typedef typename api::Point2D   Point2D;
    typedef typename api::Vector2D  Vector2D;

    typedef typename api::Point3D   Point3D;
    typedef typename api::Vector3D  Vector3D;

    typedef typename api::Matrix    Matrix;


/*---------------------------------------------------------------------------*
 | Performance & statistics
 *---------------------------------------------------------------------------*/
public:
    const RenderStatistics & frameStatistics() const { return _frameStats; }
    const RenderStatistics & totalStatistics() const { return _totalStats; }

protected:
    RenderStatistics _frameStats, _totalStats;


/*---------------------------------------------------------------------------*
 | Initialization functions
 *---------------------------------------------------------------------------*/
public:
    // Constructor
    ImmediateModeRenderer()
        : _currentRenderPass(Opacity), _currentPrimitiveType(Points) { }

    void initialize() {
        _frameStats.reset();
        _totalStats.reset();
    }

    void checkForError() { api::check_for_error(); }


/*---------------------------------------------------------------------------*
 | Framebuffer control functions
 *---------------------------------------------------------------------------*/
    // Clear the framebuffer
    void clear() {
        api::clear_framebuffer();
    }

    // Access the framebuffer (or some sub-region)
    //ImagePtr framebuffer() const;
    //ImagePtr framebuffer(index_t x, index_t y, size_t w, size_t h) const;
    //Color framebuffer(index_t x, index_t y) const;

    // Change the framebuffer's size
    void resize(size_t w, size_t h) {
        api::resize_framebuffer(w, h);
    }


/*---------------------------------------------------------------------------*
 | Rendering-state control functions (TI)
 *---------------------------------------------------------------------------*/
    void setShadingMode(ShadingMode mode) {
        switch (mode) {
        case SmoothShade:
            api::enable_lighting(true);
            api::set_shading_mode(SmoothShade);
            //glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
            break;
        case FlatShade:
            api::enable_lighting(true);
            api::set_shading_mode(FlatShade);
            //glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
            break;
        case Paint:
            api::enable_lighting(false);
            break;
        default:
            logger << "IMR::setShadingMode(" << mode << "): not supported";
            logger.warning();
        }
    }

    void enableDepthBuffering(bool enabled) { api::enable_z_buffer(false); }
    void setPointDiameter(float size) { api::set_point_size(size); }
    void setLineWidth(float width)    { api::set_line_width(width); }
    void enablePointSmoothing(bool enabled) { api::enable_point_smoothing(enabled); }
    void enableLineSmoothing(bool enabled)  { api::enable_line_smoothing(enabled); }
    void enableAlphaBlending(bool enabled)  { api::enable_alpha_blending(enabled); }

    void enableLight(world::LightPtr lite);
    void disableLight(world::LightPtr lite);
    void setBackgroundColor(world::Material::Color &c) {
        api::set_background_color(c);
    }
    template <typename scalar, imaging::ColorSpace cs, bool hasAlpha>
    void setColor(const imaging::Color<scalar, cs, hasAlpha> &c) {
        api::set_drawing_color(c);
    }

    template <typename scalar, size_t dim>
    void setNormal(const math::Vector<scalar, dim> &n) {
        api::set_normal(n);
    }

    template <typename scalar, size_t dim>
    void setTexCoords(const math::Point<scalar, dim> &t) {
        api::set_texture_coordinates(t);
    }

    void setMaterial(world::MaterialPtr mtl);


/*---------------------------------------------------------------------------*
 | Transformation matrix functions (TI)
 *---------------------------------------------------------------------------*/
    void resetTransformMatrix() {
        api::select_transformation_matrix();
        api::reset_matrix();
    }
    void saveTransformMatrix(Matrix &m) {
        api::save_transformation_matrix(m);
    }
    void loadTransformMatrix(const Matrix &m) {
        api::load_transformation_matrix(m);
    }
    void resetProjectionMatrix() {
        api::select_projection_matrix();
        api::reset_matrix();
        api::select_transformation_matrix();
    }
    void saveProjectionMatrix(Matrix &m) {
        api::save_projection_matrix(m);
    }
    void loadProjectionMatrix(const Matrix &m) {
        api::load_projection_matrix(m);
    }
    void pushTransform() {
        api::push_matrix();
    }
    void pushTransform(world::TransformConstPtr xform) {
        api::push_matrix();
        applyTransform(xform);  // Just call my buddy!
    }
    void popTransform() {
        api::pop_matrix();
    }
    void applyMatrixProjection(const Matrix &m) {
        api::select_projection_matrix();
        api::multiply_matrix(m);
        api::select_transformation_matrix();
    }
    void applyPickingProjection(const Point2D &center, const Vector2D &size) {
        api::select_projection_matrix();
        api::apply_picking_projection(center, size);
        api::select_transformation_matrix();
    }
    void applyCameraProjection(world::CameraConstPtr cam) {
        // Make sure we're not crazy here...
        if (! cam) {
            logger << "applyCameraProjection(CameraPtr): NULL pointer";
            logger.warning();
            return;     // Go home...we're done here
        }

        // See if this is a perspective camera
        world::PerspectiveCameraConstPtr pCam
            = dynamic_pointer_cast<world::PerspectiveCamera const>(cam);
        if (pCam) {
            // Extract camera view parameters
            Vector2D angles, clipping;
            angles[0] = pCam->horizViewAngle();
            angles[1] = pCam->vertViewAngle();
            clipping[0] = pCam->nearClip();
            clipping[1] = pCam->farClip();

            // Multiply in the projection matrix
            api::select_projection_matrix();
            api::apply_perspective_projection(angles, clipping);
            api::select_transformation_matrix();
            return;     // Go home...we're done here
        }

        // See if this is an orthographic camera
        world::OrthographicCameraConstPtr oCam
            = dynamic_pointer_cast<world::OrthographicCamera const>(cam);
        if (oCam) {
            // Extract camera view parameters
            Vector2D extents, clipping;
            extents[0] = oCam->viewWidth();
            extents[1] = oCam->viewHeight();
            clipping[0] = oCam->nearClip();
            clipping[1] = oCam->farClip();

            // Multiply in the projection matrix
            api::select_projection_matrix();
            api::apply_orthographic_projection(extents, clipping);
            api::select_transformation_matrix();
            return;     // Go home...we're done here
        }

        // OK...you're on crack. What the $#%@ is this??
        logger << "applyCameraProjection(CameraPtr): Unsupported Camera type "
               << typeid(cam).name();
        logger.warning();
    }
    void applyCameraTransform(world::CameraConstPtr cam) {
        // Since camera transformation is effectively the inverse model
        // transformation, we just need to send the camera's xform thru backwards
        unapplyTransform(cam->transform);
    }

    void applyTransform(world::TransformConstPtr xform) {
        // Translate, rotate, and scale
        applyTranslation(xform->position());
        applyRotation(xform->rotation());
        applyScaling(xform->scaling());
    }
    void unapplyTransform(world::TransformConstPtr xform) {
        // Unscale, unrotate, and untranslate
        unapplyScaling(xform->scaling());
        unapplyRotation(xform->rotation());
        unapplyTranslation(xform->position());
    }
    
    void applyTranslation(const world::Transform::Point &t) {
        api::apply_translation(t);
    }
    void unapplyTranslation(const world::Transform::Point &t) {
        api::unapply_translation(t);
    }

    void applyRotation(const world::Transform::Quaternion &q) {
        api::apply_rotation(q);
    }
    void unapplyRotation(const world::Transform::Quaternion &q) {
        api::unapply_rotation(q);
    }

    void applyScaling(const world::Transform::Vector &s) {
        api::apply_scaling(s);
    }
    void unapplyScaling(const world::Transform::Vector &s) {
        api::unapply_scaling(s);
    }

    // Transform a world-space coordinate into local space, and back
    world::Transform::Point transform(const world::Transform::Point &world) const {
        world::Transform::Point local;
        api::transform(world, local);
        return local;
    }
    world::Transform::Point untransform(const world::Transform::Point &local) const {
        world::Transform::Point world;
        api::untransform(local, world);
        return world;
    }

    // Transform a world-space coordinate into screen-space, and back
    world::Transform::Point project(const world::Transform::Point &world) const {
        world::Transform::Point screen;
        api::project(world, screen);
        return screen;
    }
    world::Transform::Point unproject(const world::Transform::Point &screen) const {
        world::Transform::Point world;
        api::unproject(screen, world);
        return world;
    }


/*---------------------------------------------------------------------------*
 | Selection functions (TI)
 *---------------------------------------------------------------------------*/
public:
    void setSelectionID(unsigned int id)  { api::set_selection_id(id); }
    void pushSelectionID(unsigned int id) { api::push_selection_id(id); }
    void popSelectionID()                 { api::pop_selection_id(); }
    void getSelectedIDs(world::SelectionSet &s) { api::load_selected_ids(s); }


/*---------------------------------------------------------------------------*
 | True-immediate mode rendering functions (TI)
 *---------------------------------------------------------------------------*/
    void beginFrame() {
        _frameStats.reset();
        _frameStats.beginFrame();
        _totalStats.beginFrame();
    }

    void endFrame() {
        _frameStats.endFrame();
        _totalStats.endFrame();
    }

    void beginRenderPass(RenderPass pass) {
        // Begin timing this render pass
        _frameStats.beginRenderPass(pass);
        _totalStats.beginRenderPass(pass);

        switch (pass) {
        case Opacity:
            api::set_fill_mode(Filled);         // Draw filled polyons
            api::enable_alpha_blending(false);  // No transparency
            api::lock_z_buffer(false);          // Normal Z-buffer use
            api::enable_culling(true);          // Cull back-faces
            break;
        case Wireframe:
            api::set_fill_mode(Outlined);       // Draw wireframe
            api::enable_alpha_blending(false);  // No transparency
            api::lock_z_buffer(false);          // Normal Z-buffer use
            api::enable_culling(false);         // Don't cull faces
            break;
        case Transparency:
            api::set_fill_mode(Filled);         // Draw filled polygons
            api::enable_alpha_blending(true);   // Enable transparency
            api::lock_z_buffer(true);           // Don't update Z-buffer
            api::enable_culling(false);         // Don't cull faces
            break;
        case Selection:
            api::enable_selection_mode(true);   // Enter selection mode
            api::clear_selection_id_stack();    // Start from scratch
            break;
        default:
            logger << "IMR::initializeRenderPass(" << pass << "): not supported";
            logger.warning();
        }
        // Keep track of our state
        _currentRenderPass = pass;
    }

    void endRenderPass() {
        switch (_currentRenderPass) {
        case Selection:
            api::enable_selection_mode(false);  // Finish out the selection
            break;
        }
        _frameStats.endRenderPass(_currentRenderPass);
        _totalStats.endRenderPass(_currentRenderPass);
    }

    void beginRenderImmediate(PrimitiveType type) {
        _currentPrimitiveType = type;
        api::begin_render_immediate(type);
    }
    void endRenderImmediate() {
        api::end_render_immediate();
    }

//    template <PrimitiveType p, NormalType n, TextureType t>
//    void renderImmediate(const Primitive<p, n, t> &prim);

    template <typename scalar, size_t dim>
    void renderVertex(const math::Point<scalar, dim> &p) {
        _frameStats.vertexRendered(_currentPrimitiveType, _currentRenderPass);
        _totalStats.vertexRendered(_currentPrimitiveType, _currentRenderPass);
        api::render_vertex(p);
    }

protected:
    RenderPass    _currentRenderPass;
    PrimitiveType _currentPrimitiveType;


/*---------------------------------------------------------------------------*
 | Semi-immediate mode functions
 *---------------------------------------------------------------------------*/
public:
    void render() { }
};

#endif
