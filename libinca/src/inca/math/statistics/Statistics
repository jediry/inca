/** -*- C++ -*-
 *
 * \File Statistics
 *
 * \Author Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 */

#ifndef INCA_MATH_STATISTICS
#define INCA_MATH_STATISTICS

// Import system configuration
#include <inca/inca-common.h>


namespace inca {
    namespace math {
        // Forward declarations
        template <typename Derived, typename T> class StatisticsBase;
        template <typename T, bool cacheValues = false> class Statistics;
        template <typename T> class Statistics<T, true>;
    }
}

// Import container definitions
#include <inca/util/Array>
#include <vector>


// This class implements the common functionality between the variants of
// the Statistics class. It expects the derived class to implement the
// 'processElement(ElementType)' function.
template <typename Derived, typename T>
class inca::math::StatisticsBase : public inca::Array<T, 6> {
public:
    // Type definitions
    typedef T                               ElementType;
    typedef inca::Array<ElementType, 6>     ElementArray;
    typedef inca::Array<int, 20>            Histogram;

    // Constructor
    explicit StatisticsBase()
            : ElementArray(ElementType(0)), _count(0), _histogram(0) {
        min() = ElementType(1e38);
        max() = ElementType(-1e38);
    }

    // Add in a new value
    void operator()(const ElementType & e) {
        static_cast<Derived *>(this)->processElement(e);
    }

    // Access to statistics
    ElementType & sum()       { return (*this)[0]; }
    ElementType & min()       { return (*this)[1]; }
    ElementType & max()       { return (*this)[2]; }
    ElementType & range()     { return (*this)[3]; }
    ElementType & mean()      { return (*this)[4]; }
    ElementType & variance()  { return (*this)[5]; }
    Histogram   & histogram() { return _histogram; }
    int         & count()     { return _count; }
    const ElementType & sum()       const { return (*this)[0]; }
    const ElementType & min()       const { return (*this)[1]; }
    const ElementType & max()       const { return (*this)[2]; }
    const ElementType & range()     const { return (*this)[3]; }
    const ElementType & mean()      const { return (*this)[4]; }
    const ElementType & variance()  const { return (*this)[5]; }
    const Histogram   & histogram() const { return _histogram; }
    const int         & count()     const { return _count; }

protected:
    Histogram _histogram;
    int _count;
};


// This 'general' implementation does no internal caching of the values
// it receives. As a result, it is small and light, but in order to calculate
// the variance of the sample, it must see all of the values a second
// time. This is most useful when the sample size is large and/or the
// distribution is already stored elsewhere.
template <typename T, bool cacheValues>
class inca::math::Statistics
    : public inca::math::StatisticsBase< Statistics<T, cacheValues>, T> {
public:
    // Type definitions
    typedef T                                               ElementType;
    typedef StatisticsBase< Statistics<T, cacheValues>, T > Base;

    // Import functions from base class
    using Base::sum;
    using Base::min;
    using Base::max;
    using Base::range;
    using Base::mean;
    using Base::variance;
    using Base::histogram;
    using Base::count;

    // Constructor
    explicit Statistics()
        : varSum(0), recount(0), meanValid(false), varianceValid(false) { }


    // If we've not yet calculated the mean, add this element into our running
    // sum of elements. If we have, then accumulate it towards calculating
    // the variance and histogram.
    void processElement(const ElementType & e) {
        if (! meanValid) {
            sum() += e;
            if (e < min())  min() = e;
            if (e > max())  max() = e;
            ++count();
        } else {
            ElementType diff = mean() - e;
            varSum += diff * diff;
            int bucket = e == max()
                ? histogram().size() - 1
                : static_cast<int>((e - min()) / bucketSize);
            if (bucket >= 0 && bucket < histogram().size())
                ++histogram()[bucket];
            else
                INCA_WARNING("Statistics: Sample " << e << " falls into out-of-"
                             "bounds bucket " << bucket << " of histogram ["
                             << min() << ',' << max() << ']');
            ++recount;
        }
    }

    // Finish the mean or variance calculation
    void done() {
        if (! meanValid) {
            if (count() > 0) {
                // Calculate the mean and the range
                mean() = sum() / count();
                range() = max() - min();

                // Figure out how big a histogram bucket is
                bucketSize = (max() - min()) / histogram().size();
            } else {
                max() = 0;
                min() = 0;
            }
            meanValid = true;
        } else if (! varianceValid) {
            variance() = varSum / count();
            varianceValid = true;
            if (count() != recount)
                INCA_WARNING("Statistics: Variance pass had different number "
                             "of samples: " << count() << " != " << recount);
        }
    }

    // XXX This is a bit hacked
    void setValid(bool valid) {
        meanValid = varianceValid = valid;
    }

protected:
    ElementType varSum, bucketSize;
    int recount;
    bool meanValid, varianceValid;
};


// This 'specialized' implementation caches the values it receives so
// that it can calculate the higher order moments (e.g., variance) without
// needing all the values to be passed to it a second time. It does this at
// the cost of dynamically allocating memory to hold all the elements, and
// frees that memory once its 'done()' function is called. This is most useful
// when the sample size is small and/or the values are being calculated
// on-the-fly and are not stored elsewhere.
//
// A typical use of this class might look like:
//      Statistics<int, true> s;        // Create an empty object
//      while (...)
//          s(someValue);               // Pass it each sample element
//      s.done();                       // Compute mean, variance, etc.
template <typename T>
class inca::math::Statistics<T, true>
    : public inca::math::StatisticsBase<Statistics<T, true>, T> {
public:
    // Type definitions
    typedef T                                               ElementType;
    typedef StatisticsBase< Statistics<T, true>, T>         Base;

    // Import functions from base class
    using Base::sum;
    using Base::min;
    using Base::max;
    using Base::range;
    using Base::mean;
    using Base::variance;
    using Base::histogram;
    using Base::count;


    // Constructor taking a guess as to the final size of the sample.
    // If this guess is accurate, then no additional memory will need
    // to be allocated after construction time.
    explicit Statistics(int sizeGuess = 10) {
        // Get ready to handle that many elements
        valueCache.reserve(sizeGuess);
    }

    // Handle an element and stick it into the vector
    void processElement(const ElementType & e) {
        sum() += e;
        if (e < min())  min() = e;
        if (e > max())  max() = e;
        valueCache.push_back(e);
        ++count();
    }

    // Calculate statistics of the distribution, then dump the cache
    void done() {
        if (count() > 0) {
            // Calculate the mean and the range
            mean() = sum() / count();
            range() = max() - min();

            // Calculate the variance & the histogram
            ElementType varSum(0);
            ElementType bucketSize = (max() - min()) / histogram().size();
            for (int i = 0; i < count(); ++i) {
                ElementType diff = mean() - valueCache[i];
                varSum += diff * diff;
                int bucket = valueCache[i] == max()
                    ? histogram().size() - 1
                    : static_cast<int>((valueCache[i] - min()) / bucketSize);
                if (bucket >= 0 && bucket < histogram().size())
                    ++histogram()[bucket];
                else
                    INCA_WARNING("Statistics: Sample " << valueCache[i]
                                 << " falls into out-of-bounds bucket "
                                 << bucket << " of histogram ["
                                 << min() << ',' << max() << ']');
            }
            variance() = varSum / count();

            // Clean up the cache, since we don't need it anymore
            valueCache = std::vector<ElementType>(0);

        } else {        // Crud. No elements. We need to zero out the min/max.
            max() = 0;
            min() = 0;
        }
    }

    // This is a bit hacked
    void setValid(bool valid) { }

protected:
    std::vector<ElementType> valueCache;
};

#endif
