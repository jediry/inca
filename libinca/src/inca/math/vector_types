/** -*- C++ -*-
 *
 * \file vector_types
 *
 * \author Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file implements the basic vector-math types: Point, Vector,
 *      Matrix.
 *
 *      Additionally, this file declares a macro for instantiating the
 *      various vector-like templates with ease. For example, calling:
 *          INCA_MATH_VECTOR_TYPEDEFS(double, 3, My, 3D)
 *      creates a list of typedefs something like:
 *          typedef inca::math::Vector<double, 3> MyVector3D;
 *          typedef inca::math::Point<double, 3>  MyPoint3D;
 *          .
 *          .
 *          .
 *      This permits each group of templates to be concretized fairly
 *      effortlessly. Note that either of the last two arguments to the
 *      macros (the prefix and suffix) may be omitted.
 *
 * \note In the current implementation, only those operators that \e must be
 *       defined as member functions are implemented here. The majority of
 *       the vector/matrix operations are implemented as non-member operators
 *       and functions in the file called vector_operations. This was a
 *       significant change from prior version, in which the majority of
 *       operations were implemented as member functions. This approach was
 *       abandoned because it resulted in irregular placement of operators:
 *       for example, the expression "Point * scalar_t" was a member function,
 *       but the symmetric expression "scalar_t * Point" could not be.
 *
 * \todo Document how Boost PP macros are used and the reason for using CPP here.
 */

#ifndef INCA_MATH_VECTOR_TYPES
#define INCA_MATH_VECTOR_TYPES

// Import system configuration
#include <inca/inca-common.h>


/* *
 * \def INCA_MATH_BOUNDS_CHECK
 * Enable/disable run-time array bounds-checks.
 * By setting this macro to non-zero, the inca::math vector types can be
 * configured to perform bounds-checking whenever the [] operator is used.
 * Legal values for this macro are:
 *      - \b 0 : No bounds-checks are performed. This yields the best
 *               performance, as the compiler can optimize [] access to the
 *               speed of using a raw C-style array.
 *      - \b 1 : Bounds-checking is performed and a warning is printed to
 *               stderr.
 *      - \b 2 : Bounds-checking is performed and an exception is thrown
 *               if the bounds are exceeded.
 */
#ifndef INCA_MATH_BOUNDS_CHECK
#   define INCA_MATH_BOUNDS_CHECK 0
#endif

// These control which template specializations are generated
#define MIN_DIMENSION 2
#define MAX_DIMENSION 9


// This is part of the Inca math library
namespace inca {
    namespace math {
        /*********************************************************************
         * The ScalarList template class is the base class for the other
         * array-like templates in the inca::math library. It defines the
         * usual C-array access semantics, with optional bounds-checking,
         * which must be enabled at compile-time. It cannot be instantiated
         * directly.
         *********************************************************************/
        template <typename scalar, size_t sz> class ScalarList;

        /*********************************************************************
         * The Point template class describes an infinitesimal location in
         * n-space. The usual vector mathematics operations are defined for it.
         *********************************************************************/
        template <typename scalar, size_t dim> class Point;

        /*********************************************************************
         * The Vector template class describes a pure direction in n-space.
         * The usual vector mathematics operations are defined for it.
         *********************************************************************/
        template <typename scalar, size_t dim> class Vector;

        /*********************************************************************
         * The Ray template class represents both a location and a direction
         * in n-space. It is made up of a Point and a Vector.
         *********************************************************************/
        template <typename scalar, size_t dim> class Ray;

        /*********************************************************************
         * The Matrix template class is a two-dimensional scalar grid, possibly
         * representing a geometric transformation. The usual matrix operations
         * are defined for it.
         *********************************************************************/
        template <typename scalar, size_t maj, size_t min,
                  bool rowMajAccess = true, bool rowMajorStorage = true>
        class Matrix;

        /*********************************************************************
         * The Quaternion template class represents a rotation in 3-space.
         *********************************************************************/
        template <typename scalar> class Quaternion;
    };
};


// Import the Boost preprocessor metaprogramming library
#include <boost/preprocessor/arithmetic/inc.hpp>
#include <boost/preprocessor/arithmetic/mul.hpp>
#include <boost/preprocessor/repetition/repeat_from_to.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>

// Import template metaprogramming constraints
#include <boost/type_traits.hpp>
#include <inca/util/metaprogramming>

// Import scalar_traits definition
#include "scalar_types"


// Implementation of our base class, which inherits the scalar implementation
// in order to get easy access to mathematical functions.
template <typename scalar, size_t sz>
class inca::math::ScalarList {
public:
    // Scalar implementation typedefs
    INCA_MATH_SCALAR_TYPEDEFS(scalar, IS_WITHIN_TEMPLATE, /* */, /* */);

    // What dimensional space are we working in?
    static const size_t size = sz;


protected:
    /** Protected default constructor (not directly instantiatable). */
    ScalarList() { }


public:
    /**
     * Array subscript accessor operator definition. This returns a reference
     * to the requested item in the array.
     */
    const scalar_t & operator[](index_t i) const { return elements[i]; }
    scalar_t & operator[](index_t i) { return elements[i]; }

    /**
     * Pointer to internal C-style array used to hold elements.
     */
    const scalar_t * contents() const { return elements; }
    scalar_t * contents() { return elements; }

    /**
     * Creates a string representation of elements in this list.
     * This version
     * \returns a string containing a comma-separated list of scalars
     */
    string stringifyElements() const {
        return stringifyElements(0, size);
    }

    /**
     * \overload stringifyElements()
     * This version allows to specify the index range which should be
     * stringified. If either \a start or \a (start + num * stride) are
     * outside the range * [0, size - 1], they will be clamped to the nearest
     * valid index.
     *
     * \param start     the index of the first element to stringify
     * \param num       the number of elements to print
     * \param stride    the stride length to take through the list with each
     *                  element we print. If this is \c 1, all elements in
     *                  the range will be printed; if \c 2, every other, etc.
     * \returns a string containing a comma-separated list of scalars
     */
    string stringifyElements(index_t start,
                             index_t num,
                             size_t stride = 1) const {
        index_t end = start + num * stride;
        if (start < 0)          start = 0;
        else if (start >= size) start = size;
        if (end < 0)            end = 0;
        else if (end >= size)   end = size;
        ostringstream ss;
        for (index_t i = start; i < end; i += stride) {
            ss << elements[i];
            if (index_t(i + stride) < end)  ss << ", ";
        }
        return ss.str();
    }

protected:
    /** The scalar elements that make up this list object. */
    scalar_t elements[size];
};


// Implementation of Quaternion. As quaternions are, by their very nature,
// 4D, there is no need to use the preprocessor to write the template.
template <typename scalar>
class inca::math::Quaternion : public ScalarList<scalar, 4> {
public:
    // Scalar implementation typedefs
    INCA_MATH_SCALAR_TYPEDEFS(scalar, IS_WITHIN_TEMPLATE, /* */, /* */);

    /** Default (no initialization) constructor. */
    explicit Quaternion() { }

    /** scalar_t array constructor. */
    Quaternion(scalar_t e[size]) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e[i];
    }

    /**
     * scalar_t argument list constructor.
     */
    explicit Quaternion(scalar_arg_t s, scalar_arg_t vx,
                        scalar_arg_t vy, scalar_arg_t vz) {
        elements[0] = s;    elements[1] = vx;
        elements[2] = vy;   elements[3] = vz;
    }

    /**
     * scalar_t with Vector constructor.
     */
    explicit Quaternion(scalar_arg_t s, const Vector<scalar, 3> &v) {
        elements[0] = s;
        for (index_t i = 0; i < 3; i++)
            elements[i + 1] = v[i];
    }

    /**
     * Point constructor
     */
    explicit Quaternion(const Point<scalar, 3> &p) {
        elements[0] = 0.0;
        for (index_t i = 0; i < 3; i++)
            elements[i + 1] = p[i];
    }

    /**
     * Vector constructor
     */
    explicit Quaternion(const Vector<scalar, 3> &v) {
        elements[0] = 0.0;
        for (index_t i = 0; i < 3; i++)
            elements[i + 1] = v[i];
    }

    /**
     * Cast to string representation.
     * \returns a string like "(1.4, 3.5)"
     */
    operator string() const {
        return string("[") + elements[0] + " (" + stringifyElements() + ")]";
    }
};

// This macro is used by the calls to BOOST_PP_REPEAT to assign constructor
// parameters to their corresponding slot in the list
#define ASSIGN_ARG(Z, IDX, JUNK) elements[IDX] = e ## IDX;

// This macro is used to instantiate the variable-arg-count constructors
#define PARAM_LIST_CONSTRUCTOR(Z, DIM, CLASS)                               \
    explicit CLASS(BOOST_PP_ENUM_PARAMS(DIM, scalar_arg_t e)) {             \
        /* Cause a compile-time failure if this constructor is used with    \
         * an instance of the wrong dimensionality.                         \
         */                                                                 \
        BOOST_STATIC_ASSERT(DIM == size);                                   \
                                                                            \
        /* Copy each paramter to its slot in the array */                   \
        BOOST_PP_REPEAT(DIM, ASSIGN_ARG, BOOST_PP_EMPTY);                   \
    }

// This macro is used to instantiate the List<N>(List<N-1>, scalar) constructors
#define UP_DIM_CONSTRUCTOR(Z, K, CLASS)                                     \
    explicit CLASS(const CLASS<scalar_t, dim - K> &lst,                     \
                   BOOST_PP_REPEAT(K,                                       \
        /* Cause a compile-time failure if this constructor is used with    \
         * an instance of the wrong dimensionality.                         \
         */                                                                 \
        BOOST_STATIC_ASSERT(DIM == size);                                   \
                                                                            \
        /* Copy each paramter to its slot in the array */                   \
        BOOST_PP_REPEAT(DIM, ASSIGN_ARG, BOOST_PP_EMPTY);                   \
// This macro is a shortcut for a function constraint specifying that the first
// type must be convertible to the second
#define IS_CONVERTIBLE(T1, T2) typename constraint<boost::is_convertible<T1, T2>::satisfied = 0


template <typename scalar, size_t dim>
class inca::math::Point : public ScalarList<scalar, dim> {
public:
    /* Scalar implementation typedefs */
    INCA_MATH_SCALAR_TYPEDEFS(scalar, IS_WITHIN_TEMPLATE, /* */, /* */);

    /** Default (no initialization) constructor. */
    explicit Point() { }

    /** Initialization from another list type */
    explicit Point(const ScalarList<scalar, dim> &lst)
        : ScalarList<scalar, dim>(lst) { }

    /** Constant initialization constructor. */
    explicit Point(scalar_arg_t e) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e;
    }
 
    /** scalar_t array constructor. */
    Point(scalar_t e[size]) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e[i];
    }

    /**
     * scalar_t argument list constructors. Each of these is intended to be used
     * only with instances of the same dimensionality as there are arguments.
     * Attempting to invoke a constructor for a different dimensionality will
     * cause a compile-time failure.
     */
    BOOST_PP_REPEAT_FROM_TO(MIN_DIMENSION, MAX_DIMENSION,
                            PARAM_LIST_CONSTRUCTOR, Point);

    /**
     * Cross-scalar assignment constructor. This constructor accepts a Point of
     * a different scalar type, provided that it has the same dimensionality
     * and that its scalar type is convertible to this Point's type.
     * FIXME This doesn't check compatibility of type!
     */
    template <typename scalar2>
    Point(const Point<scalar2, dim> &p) {
        for (index_t i = 0; i < size; ++i)
            elements[i] = p[i];
    }

    /**
     * Cast to string representation.
     * \returns a string like "(1.4, 3.5)"
     */
    operator string() const {
        return '(' + stringifyElements() + ')';
    }
};


template <typename scalar, size_t dim>
class inca::math::Vector : public ScalarList<scalar, dim> {
public:
    /* Scalar implementation typedefs */
    INCA_MATH_SCALAR_TYPEDEFS(scalar, IS_WITHIN_TEMPLATE, /* */, /* */);

    /** Default (no initialization) constructor. */
    explicit Vector() { }

    /** Initialization from another list type */
    explicit Vector(const ScalarList<scalar, dim> &lst)
        : ScalarList<scalar, dim>(lst) { }

    /** Constant initialization constructor. */
    explicit Vector(scalar_arg_t e) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e;
    }
 
    /** scalar_t array constructor. */
    Vector(scalar_t e[size]) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e[i];
    }

    /** Initialization from another list type */
    explicit Vector(const Quaternion<scalar> &q) {
        /* We should complain bitterly if the dimension != 3 */
        elements[0] = q[1]; elements[1] = q[2]; elements[2] = q[3];
    }

    /**
     * scalar_t argument list constructors. Each of these is intended to be used
     * only with instances of the same dimensionality as there are arguments.
     * Attempting to invoke a constructor for a different dimensionality will
     * cause a compile-time failure.
     */
    BOOST_PP_REPEAT_FROM_TO(MIN_DIMENSION, MAX_DIMENSION,
                            PARAM_LIST_CONSTRUCTOR, Vector);

    /**
     * Cross-scalar assignment constructor. This constructor accepts a Vector of
     * a different scalar type, provided that it has the same dimensionality
     * and that its scalar type is convertible to this Vector's type.
     * FIXME This doesn't check compatibility of type!
     */
    template <typename scalar2>
    Vector(const Vector<scalar2, dim> &p) {
        for (index_t i = 0; i < size; ++i)
            elements[i] = p[i];
    }

    /**
     * Cast to string representation.
     * \returns a string like "(1.4, 3.5)"
     */
    operator string() const {
        return '(' + stringifyElements() + ')';
    }
};


// This macro expands to create a partial template specialization of Ray
// with the dimension fixed. This trick is necessary to create ONLY the
// appropriate scalar_t argument list constructors.
#define INCA_MATH_RAY_TEMPLATE(Z, DIM, JUNK)                                \
template <typename scalar>                                                  \
class Ray<scalar, DIM> {                                                    \
public:                                                                     \
    /* Scalar implementation typedefs */                                    \
    INCA_MATH_SCALAR_TYPEDEFS(scalar, IS_WITHIN_TEMPLATE, /* */, /* */);    \
                                                                            \
    /** Default (no initialization) constructor. */                         \
    explicit Ray() { }                                                      \
                                                                            \
    /** scalar_t array constructor. */                                      \
    Ray(scalar_t e[BOOST_PP_MUL(DIM, 2)])                                   \
       : _position(e), _direction(e + DIM) { }                              \
                                                                            \
    /**                                                                     \
     * scalar_t argument list constructor. This constructor takes a number  \
     * of arguments twice the dimension. The first set of arguments is      \
     * interpreted as the position, and the second set as the direction.    \
     */                                                                     \
    explicit Ray(BOOST_PP_ENUM_PARAMS(BOOST_PP_MUL(DIM, 2), scalar_arg_t e))\
        : _position(BOOST_PP_ENUM_PARAMS_FROM_TO(0, BOOST_PP_DEC(DIM), e)), \
          _direction(BOOST_PP_ENUM_PARAMS_FROM_TO(DIM,                      \
                               BOOST_PP_DEC(BOOST_PP_MUL(DIM, 2)), e)) { }  \
                                                                            \
    /**                                                                     \
     * The positional part of this ray.                                     \
     */                                                                     \
    Point<scalar, DIM> & position() { return _position; }                   \
                                                                            \
    /**                                                                     \
     * The directional part of this ray.                                    \
     */                                                                     \
    Vector<scalar, DIM> & direction() { return _direction; }                \
                                                                            \
    /**                                                                     \
     * Cast to string representation.                                       \
     * \returns a string like "(1.4, 3.5) ->(0.0, 3.0)"                     \
     */                                                                     \
    operator std::string() const {                                          \
        return string(_position) + " ->" + _direction;                      \
    }                                                                       \
                                                                            \
protected:                                                                  \
    Point<scalar, DIM>  _position;                                          \
    Vector<scalar, DIM> _direction;                                         \
};


template <typename scalar, size_t _major, size_t _minor,
          bool _rowMajorAccess, bool _rowMajorStorage>
class inca::math::Matrix : public ScalarList<scalar, _major * _minor> {
public:
    /* Scalar implementation typedefs */
    INCA_MATH_SCALAR_TYPEDEFS(scalar, IS_WITHIN_TEMPLATE, /* */, /* */);

    /** What size matrix are we working with? */
    static const size_t major = _major;
    static const size_t minor = _minor;
    static const bool rowMajorAccess =   _rowMajorAccess;
    static const bool colMajorAccess = ! _rowMajorAccess;
    static const bool rowMajorStorage =   _rowMajorStorage;
    static const bool colMajorStorage = ! _rowMajorStorage;
    static const size_t rows = rowMajorAccess ? major : minor;
    static const size_t cols = colMajorAccess ? major : minor;

    /** Default (no initialization) constructor. */
    explicit Matrix() { }

    /** Constant initialization constructor. */
    explicit Matrix(scalar_arg_t e) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e;
    }

    /**
     * scalar_t argument list constructors. Each of these is intended to be used
     * only with instances with the same number of elements as there are
     * arguments. Attempting to invoke a constructor for a different
     * dimensionality will cause a compile-time failure.
     */
//    BOOST_PP_REPEAT_FROM_TO(MIN_DIMENSION * MIN_DIMENSION,
//                            MAX_DIMENSION * MAX_DIMENSION,
//                            PARAM_LIST_CONSTRUCTOR, Matrix);

    /** scalar_t array constructor. */
    explicit Matrix(scalar_t e[size]) {
        for (index_t i = 0; i < size; i++)
            elements[i] = e[i];
    }

    /** scalar_t double array constructor. */
    explicit Matrix(scalar_t e[major][minor]) {
        for (index_t i = 0; i < major; i++)
            for (index_t j = 0; j < minor; j++)
                elements[indexOf(i, j)] = e[i][j];
    }

    /**
     * 2D matrix-subscript element accessor.
     */
    const scalar_t & operator()(index_t maj, index_t min) const {
        return elements[indexOf(maj, min)];
    }
    scalar_t & operator()(index_t maj, index_t min) {
        return elements[indexOf(maj, min)];
    }

    /**
     * 2D, storage-order-independent element accessor.
     */
    const scalar_t & rowCol(index_t r, index_t c) const {
        return elements[rowMajorStorage ? r * cols + c : c * rows + r];
    }
    scalar_t & rowCol(index_t r, index_t c) {
        return elements[rowMajorStorage ? r * cols + c : c * rows + r];
    }

    /**
     * 2D, storage-order-independent element accessor.
     */
    const scalar_t & colRow(index_t c, index_t r) const {
        return rowCol(r, c);
    }
    scalar_t & colRow(index_t c, index_t r) {
        return rowCol(r, c);
    }

    /**
     * Calculate a 1D index into the underlying ScalarList from a pair of
     * major-axis, minor-axis subscripts.
     */
    index_t indexOf(index_t maj, index_t min) const {
        if (rowMajorStorage == rowMajorAccess)  // Same access as storage
            return maj * minor + min;
        else
            return min * major + maj;
    }

    /**
     * Cast to string representation.
     * \returns a string like "[1.4, 3.5]\n[0.0, 3.0]"
     */
    operator string() const {
        ostringstream ss;
        for (index_t row = 0; row < rows; row++)
            // Stringify a single row in the matrix. This has to be done
            // differently, depending on the storage scheme
            if (colMajorStorage)
                ss << '[' << stringifyElements(row, cols, rows) << "]\n";
            else
                ss << '[' << stringifyElements(row * cols, cols, 1) << "]\n";
        return ss.str();
    }
};


// Macro to typedef vector thingies
#define INCA_MATH_VECTOR_TYPEDEFS(SCALAR, DIM, PREF, SUFF)                   \
    typedef inca::math::Point<SCALAR, DIM>       PREF ## Point      ## SUFF; \
    typedef inca::math::Vector<SCALAR, DIM>      PREF ## Vector     ## SUFF; \
    typedef inca::math::Ray<SCALAR, DIM>         PREF ## Ray        ## SUFF; \
    typedef inca::math::Matrix<SCALAR, DIM, DIM> PREF ## Matrix     ## SUFF; \
    typedef inca::math::Quaternion<SCALAR>       PREF ## Quaternion ## SUFF;


// Last of all, clean up the preprocessor namespace on our way out
#undef MAX_DIMENSION
#undef MIN_DIMENSION
#undef ASSIGN_ARG
#undef PARAM_LIST_CONSTRUCTOR
#undef UP_DIM_CONSTRUCTOR
#undef DOWN_DIM_CONSTRUCTOR
#undef IS_CONVERTIBLE

#endif
