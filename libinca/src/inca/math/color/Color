/* -*- C++ -*-
 *
 * File: Color
 *
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 */


#ifndef INCA_MATH_COLOR
#define INCA_MATH_COLOR

// Import system configuration
#include <inca/inca-common.h>

// This is part of the Inca math library
namespace inca {
    namespace math {
        // Forward declarations
        template <typename scalar, class colorspace> class Color;
    };
};

// Import superclass definition
#include <boost/array.hpp>

// Import scalar math definition
#include "../scalar.hpp"

// Import math macros
#include "../macros.hpp"


template <typename scalar, class colorspace>
class inca::math::Color : public boost::array<scalar, colorspace::components> {
/*---------------------------------------------------------------------------*
 | Type/constant declarations
 *---------------------------------------------------------------------------*/
public:
    // Scalar typedefs
    INCA_MATH_SCALAR_TYPES(scalar, IS_WITHIN_TEMPLATE);


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    /**
     * Default (no initialization) constructor.
     */
    explicit Color() { }

    /**
     * Initialization from another array type, possibly of a different scalar
     * type. The argument array must be of the same dimensionality, and its
     * scalar type must be convertible to scalar_t.
     */
    template <typename scalar2>
    explicit Color(const boost::array<scalar2, static_size> &arr) {
        std::copy(arr.begin(), arr.end(), begin());
    }

    /**
     * Constant element initialization constructor
     */
    explicit Color(scalar_arg_t e) {
        std::fill(begin(), end(), e);
    }
 
    /**
     * C-style array constructor. The element type must be convertible to
     * scalar_t.
     */
    template <typename scalar2>
    explicit Color(scalar2 * arr) {
        std::copy(arr, arr + static_size, begin());
    }

    /**
     * scalar_arg_t argument list constructors. Each of these is intended to
     * be used only with instances of the same dimensionality as there are
     * arguments. Attempting to invoke a constructor for a different
     * dimensionality will cause a compile-time failure.
     */
    PARAM_LIST_CONSTRUCTORS(Color, MIN_DIMENSION, MAX_DIMENSION)


/*---------------------------------------------------------------------------*
 | Type-conversion functions
 *---------------------------------------------------------------------------*/
public:
    // to-string Cast
    operator string() const {
        std::ostringstream str;
        str << "Color[" << colorSpace << "]: (" << stringifyElements() << ')';
        return str.str();
    }
};

/*
// Rhs color is the one "on top"
template <typename scalar, ColorSpace cs, bool hasAlpha>
Color<scalar, cs, hasAlpha> operator%(const Color<scalar, cs, hasAlpha> &c1,
                                      const Color<scalar, cs, true> &c2) {
    // The number of actual "color" channels (excluding alpha)
    std::size_t components = colorspace_traits<cs, false>::components;

    // Either c1 has alpha, or we assign it an alpha of 1
    scalar alphaC1 = hasAlpha ? c1[components] : scalar(1);
    scalar alphaC2 = c2[components];
    scalar alphaR  = alphaC2 + alphaC1 * (1 - alphaC2);

    Color<scalar, cs, hasAlpha> result;

    // Do the associative color thing
    for (index_t i = 0; i < index_t(components); i++) {
        result[i] = (alphaC2 * c2[i]
                     + (alphaC1 * c1[i]) * (1 - alphaC2)) / alphaR;
    }

    // If we have an alpha channel, store the new alpha
    if (hasAlpha)
        result[components] = alphaR;

    return result;
}


template <typename s, ColorSpace cs, bool alpha>
std::ostream & operator<<(std::ostream &os, const Color<s, cs, alpha> &c) {
    os << '<';
    for (index_t i = 0; i < index_t(c.size) - 1; ++i)
        os << c[i] << ", ";
    os << c[c.size - 1] << '>';
    return os;
}

*/
// Clean up the preprocessor's namespace
#define UNDEFINE_INCA_MATH_MACROS
#include "../macros.hpp"

#endif
