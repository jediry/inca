/* -*- C++ -*-
 *
 * File: WingedEdge-PolygonMesh
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2003, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file implements a polygon mesh based on the winged-edge
 *      data structure.
 *
 *      All of the algorithms here assume that vertices are oriented
 *      CCW (viewed from the "outside" of the face). If face vertices
 *      are consistently specifed using a CW orientation, then
 *      everything will work fine topologically, but the "inside"
 *      and "outside" of the mesh will be reversed. If CW and CCW
 *      orientations are intermixed, then a topological conflict will
 *      occur at some point (assuming that the mesh represents a
 *      closed solid). When the conflict is detected, it will be
 *      corrected by reversing some of the faces in the mesh.
 *
 *      The algorithms for adding and deleting parts of the mesh are
 *      a bit tricky, and so are extensively commented.
 */
// TODO: add checks for un-closed solid
// FIXME: add functionality to completely reverse the rotations on a
//        contiguous patch
// FIXME: copy/mirror geometry is sorta busted


#ifndef INCA_POLY_WE_POLYGON_MESH
#define INCA_POLY_WE_POLYGON_MESH

// This is part of the Inca polygon modeling library
namespace inca {
    namespace poly {
        // Forward declarations
        template <typename scalar, size_t dim> class WEPolygonMesh;
    };
};


// Import mesh sub-objects
#include "WingedEdge-Vertex"
#include "WingedEdge-Face"
#include "WingedEdge-Edge"
#include "WingedEdge-FaceVertex"


// Import exception definitions
#include "NonManifoldGeometryException.hpp"
#include <inca/util/UnsupportedOperationException.hpp>

// Import container definitions
#include <inca/util/object_pool>


template <typename scalar, size_t dim>
class inca::poly::WEPolygonMesh {
public:
    // What dimensional space are we working in?
    const static size_t dimension = dim;

    // Template typedefs
    typedef WEPolygonMesh<scalar, dim>  PolygonMesh;
    typedef WEVertex<scalar, dim>       Vertex;
    typedef WEFace<scalar, dim>         Face;
    typedef WEEdge<scalar, dim>         Edge;
    typedef WEFaceVertex<scalar, dim>   FaceVertex;
    typedef PolygonMesh *               PolygonMeshPtr;
    typedef Vertex *                    VertexPtr;
    typedef Face *                      FacePtr;
    typedef Edge *                      EdgePtr;
    typedef FaceVertex *                FaceVertexPtr;

    typedef math::Point<scalar, dim>    Point;
    typedef math::Vector<scalar, dim>   Vector;
    typedef math::Point<float, 2>      TexCoords;

    typedef scalar       scalar_t;
    typedef scalar scalar_arg_t;

    typedef vector<VertexPtr>           VertexPtrList;
    typedef vector<FacePtr>             FacePtrList;
    typedef vector<EdgePtr>             EdgePtrList;
    typedef vector<FaceVertexPtr>       FaceVertexPtrList;
    typedef vector<Point>               PointList;
    typedef vector<Vector>              VectorList;
    typedef vector<TexCoords>           TexCoordsList;


/*---------------------------------------------------------------------------*
 | Sub-object management
 *---------------------------------------------------------------------------*/
protected:
    // A 'reset()' functor that calls 'clear()' on the target object before
    // the ObjectPool hands it out
    template <class T>
    struct reset_clear {
        void operator() (T *ptr) const { ptr->clear(); }
    };
    
    // A 'create()' functor that calls 'setID(...)' on the target object after
    // creating it
    template <class T>
    struct id_create {
        T * operator() (index_t index) const {
            T *ptr = new T();
            ptr->setID(index);
            return ptr;
        }
    };

    // ObjectPool typedefs
    typedef object_pool<Vertex, reset_clear<Vertex>,
                        id_create<Vertex> >                 VertexPool;
    typedef object_pool<Face, reset_clear<Face>,
                        id_create<Face> >                   FacePool;
    typedef object_pool<Edge, reset_clear<Edge>,
                        id_create<Edge> >                   EdgePool;
    typedef object_pool<FaceVertex, reset_clear<FaceVertex>,
                        id_create<FaceVertex> >             FaceVertexPool;


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    // Default Initializer
    WEPolygonMesh() {
//        createTexCoords(TexCoords(0.0));    // These represent "no data"
//        createNormal(Vector(0.0));
    }

    // Copy constructor
    WEPolygonMesh(const PolygonMesh &mesh)
            : vertexPool(mesh.vertexCount()), facePool(mesh.faceCount()),
              edgePool(mesh.edgeCount()), faceVertexPool(mesh.faceVertexCount()) {
        // Now build a copy of the source mesh
        mirror(mesh, CloneVertexHandler());
    }
    
    // Flattening constructor (drop one dimension)
    WEPolygonMesh(const WEPolygonMesh<scalar, dimension + 1> &mesh,
                  index_t discard)
            : vertexPool(mesh.vertexCount()),  facePool(mesh.faceCount()),
              edgePool(mesh.edgeCount()), faceVertexPool(mesh.faceVertexCount()) {
              
        if (discard > dimension) {
            logger << "WEPolygonMesh" << (dimension + 1) << "D: "
                      "dimension " << discard << " is out of range. Choosing "
                      "to discard last dimension " << dimension;
            logger.error();
            discard = dimension;
        }

        // Now build a flattened copy of the source mesh
        mirror(mesh, FlattenVertexHandler(discard));
    }


/*---------------------------------------------------------------------------*
 | Mesh mirroring operations: clone, flatten, etc.
 *---------------------------------------------------------------------------*/
protected:
    struct CloneVertexHandler {
        // Initialize the new vertex from the old one
        void operator()(Vertex &newV, const Vertex &oldV) const {
            newV.setLocation(oldV.getLocation());
        }
    };

    struct FlattenVertexHandler {
        // Constructor
        FlattenVertexHandler(index_t dscd) : discard(dscd) {
            if (discard > dimension)
                discard = dimension;
        }

        // Initialize the new vertex from the old one
        void operator()(Vertex &newV,
                        const WEVertex<scalar, dimension + 1> &oldV) const {
            index_t ni = 0;
            for (index_t oi = 0; oi < dimension + 1; oi++)
                if (oi != discard)  // Ignore the specified index
                    newV[ni++] = oldV[oi];    // Copy over the coordinate
        }

    protected:
        index_t discard;
    };

    template<unsigned int oldDim, class VertexHandler>
    void mirror(const WEPolygonMesh<scalar, oldDim> &mesh,
                VertexHandler &handler) {
        // The old guy
        typedef WEPolygonMesh<scalar, oldDim>   OldPolygonMesh;
        typedef typename OldPolygonMesh::VertexPtr       OldVertexPtr;
        typedef typename OldPolygonMesh::FacePtr         OldFacePtr;
        typedef typename OldPolygonMesh::EdgePtr         OldEdgePtr;
        typedef typename OldPolygonMesh::FaceVertexPtr   OldFaceVertexPtr;

        // These'll be useful for resolving correspondence 'tween old and new
        typedef hash_map<OldVertexPtr, VertexPtr>           VertexPtrMap;
        typedef hash_map<OldFacePtr, FacePtr>               FacePtrMap;
        typedef hash_map<OldEdgePtr, EdgePtr>               EdgePtrMap;
        typedef hash_map<OldFaceVertexPtr, FaceVertexPtr>   FaceVertexPtrMap;

        VertexPtrMap vertexMap;
        FacePtrMap faceMap;
        EdgePtrMap edgeMap;
        FaceVertexPtrMap faceVertexMap;

        // Clone all the parts and set up mappings with the originals
        for (index_t i = 0; i < mesh.vertexCount(); i++) {
            VertexPtr newV = newVertex();
            vertexMap[mesh.vertex(i)] = newV;
        }
        for (index_t i = 0; i < mesh.faceCount(); i++) {
            FacePtr newF = newFace();
            faceMap[mesh.face(i)] = newF;
        }
        for (index_t i = 0; i < mesh.edgeCount(); i++) {
            EdgePtr newE = newEdge();
            edgeMap[mesh.edge(i)] = newE;
        }
        for (index_t i = 0; i < mesh.faceVertexCount(); i++) {
            FaceVertexPtr newFV = newFaceVertex();
            faceVertexMap[mesh.faceVertex(i)] = newFV;
        }

        // Go back and link everything just like it was
        for (index_t i = 0; i < mesh.vertexCount(); i++) {
            const OldVertexPtr oldV = mesh.vertex(i);
            VertexPtr newV = vertexMap[oldV];
            handler(*newV, *oldV);      // Copy over the coordinates
            newV->setLinkEdge(edgeMap[oldV->getLinkEdge()]);
        }
        for (index_t i = 0; i < mesh.faceCount(); i++) {
            const OldFacePtr oldF = mesh.face(i);
            FacePtr newF = faceMap[oldF];
            newF->setLinkEdge(edgeMap[oldF->getLinkEdge()]);
        }
        for (index_t i = 0; i < mesh.edgeCount(); i++) {
            const OldEdgePtr oldE = mesh.edge(i);
            EdgePtr newE = edgeMap[oldE];
            newE->setStartVertex(vertexMap[oldE->getStartVertex()]);
            newE->setEndVertex(vertexMap[oldE->getEndVertex()]);
            newE->setPositiveFace(faceMap[oldE->getPositiveFace()]);
            newE->setNegativeFace(faceMap[oldE->getNegativeFace()]);
            newE->setPositiveCWEdge(edgeMap[oldE->getPositiveCWEdge()]);
            newE->setPositiveCCWEdge(edgeMap[oldE->getPositiveCCWEdge()]);
            newE->setNegativeCWEdge(edgeMap[oldE->getNegativeCWEdge()]);
            newE->setNegativeCCWEdge(edgeMap[oldE->getNegativeCCWEdge()]);
            newE->setPositiveCWFaceVertex(edgeMap[oldE->getPositiveCWFaceVertex()]);
            newE->setPositiveCCWFaceVertex(edgeMap[oldE->getPositiveCCWFaceVertex()]);
            newE->setNegativeCWFaceVertex(edgeMap[oldE->getNegativeCWFaceVertex()]);
            newE->setNegativeCCWFaceVertex(edgeMap[oldE->getNegativeCCWFaceVertex()]);
        }
        for (index_t i = 0; i < mesh.faceVertexCount(); i++) {
            const OldFaceVertexPtr oldFV = mesh.faceVertex(i);
            FaceVertexPtr newFV = faceVertexMap[oldFV];
            newFV->setVertex(faceVertexMap[oldFV->getVertex()]);
            newFV->setFace(faceVertexMap[oldFV->getFace()]);
            newFV->setCWEdge(faceVertexMap[oldFV->getCWEdge()]);
            newFV->setCCWEdge(faceVertexMap[oldFV->getCCWEdge()]);
        }
    }

protected:
    // Where we get new stuff from
    VertexPool      vertexPool;
    FacePool        facePool;
    EdgePool        edgePool;
    FaceVertexPool  faceVertexPool;

    // Where we store the ones we're using
    VertexPtrList       vertexList;
    FacePtrList         faceList;
    EdgePtrList         edgeList;
    FaceVertexPtrList   faceVertexList;

    // Where we store geometric data
    PointList   locationList;
    VectorList  normalList;
    TexCoordsList texCoordsList;


/*---------------------------------------------------------------------------*
 | Geometrical object accessor functions
 *---------------------------------------------------------------------------*/
public:
    // Location accessors
          Point & location(index_t i)       { return locationList[i]; }
    const Point & location(index_t i) const { return locationList[i]; }
          PointList & locations()       { return locationList; }
    const PointList & locations() const { return locationList; }
    size_t locationCount() const { return locationList.size(); }

    // Normal accessors
          Vector & normal(index_t i)       { return normalList[i]; }
    const Vector & normal(index_t i) const { return normalList[i]; }
          VectorList & normals()       { return normalList; }
    const VectorList & normals() const { return normalList; }
    size_t normalCount() const { return normalList.size(); }

    // TexCoords accessors
          TexCoords & texCoords(index_t i)       { return texCoordsList[i]; }
    const TexCoords & texCoords(index_t i) const { return texCoordsList[i]; }
          TexCoordsList & texCoords()       { return texCoordsList; }
    const TexCoordsList & texCoords() const { return texCoordsList; }
    size_t texCoordsCount() const { return texCoordsList.size(); }

    // Are things enabled?
    bool hasTexCoords() const { return texCoordsList.size() > 0; }
    bool hasNormals()   const { return normalList.size() > 0; }


/*---------------------------------------------------------------------------*
 | Topological object accessor functions
 *---------------------------------------------------------------------------*/
public:
    // Vertex accessors
          VertexPtr vertex(index_t i)       { return vertexList[i]; }
    const VertexPtr vertex(index_t i) const { return vertexList[i]; }
          VertexPtrList & vertices()       { return vertexList; }
    const VertexPtrList & vertices() const { return vertexList; }
    size_t vertexCount() const { return vertexList.size(); }

    // Face accessors
          FacePtr face(index_t i)       { return faceList[i]; }
    const FacePtr face(index_t i) const { return faceList[i]; }
          FacePtrList & faces()       { return faceList; }
    const FacePtrList & faces() const { return faceList; }
    size_t faceCount() const { return faceList.size(); }

    // Edge accessors
          EdgePtr edge(index_t i)       { return edgeList[i]; }
    const EdgePtr edge(index_t i) const { return edgeList[i]; }
          EdgePtrList & edges()       { return edgeList; }
    const EdgePtrList & edges() const { return edgeList; }
    size_t edgeCount() const { return edgeList.size(); }

    // FaceVertex accessors
          FaceVertexPtr faceVertex(index_t i)       { return faceVertexList[i]; }
    const FaceVertexPtr faceVertex(index_t i) const { return faceVertexList[i]; }
          FaceVertexPtrList & faceVertices()       { return faceVertexList; }
    const FaceVertexPtrList & faceVertices() const { return faceVertexList; }
    size_t faceVertexCount() const { return faceVertexList.size(); }


/*---------------------------------------------------------------------------*
 | Sub-object management functions
 *---------------------------------------------------------------------------*/
protected:
    // Low-level single vertex creation
    VertexPtr acquireVertex() {
        VertexPtr v = vertexPool.acquire();
        v->setMesh(this);
        vertexList.push_back(v);

        // Make sure we have storage
        while (size_t(v->getID()) >= locationList.size())
            locationList.push_back(Point());
        v->setLocationIndex(v->getID());
        return v;
    }

    // Low-level single face creation
    FacePtr acquireFace() {
        FacePtr f = facePool.acquire();
        f->setMesh(this);
        faceList.push_back(f);
        return f;
    }

    // Low-level single face creation
    EdgePtr acquireEdge() {
        EdgePtr e = edgePool.acquire();
        e->setMesh(this);
        edgeList.push_back(e);
        return e;
    }

    // Low-level single faceVertex creation
    FaceVertexPtr acquireFaceVertex() {
        FaceVertexPtr fv = faceVertexPool.acquire();
        fv->setMesh(this);
        faceVertexList.push_back(fv);
        return fv;
    }

    // Low-level single vertex disposal
    void releaseVertex(VertexPtr v) {
        typename VertexPtrList::iterator it = find(vertexList.begin(), vertexList.end(), v);
        if (it == vertexList.end()) {       // We never owned this...
            cerr << "Attempted to release non-acquired vertex "
                 << v->getID() << '\n';
        } else {                            // Ok. We can clean up now
            vertexList.erase(it);
            vertexPool.release(v);
        }
    }

    // Low-level single face disposal
    void releaseFace(FacePtr f) {
        typename FacePtrList::iterator it = find(faceList.begin(), faceList.end(), f);
        if (it == faceList.end()) {         // We never owned this...
            cerr << "Attempted to release non-acquired face "
                 << f->getID() << '\n';
        } else {                            // Ok. We can clean up now
            faceList.erase(it);
            facePool.release(f);
        }
    }

    // Low-level single edge disposal
    void releaseEdge(EdgePtr e) {
        typename EdgePtrList::iterator it = find(edgeList.begin(), edgeList.end(), e);
        if (it == edgeList.end()) {       // We never owned this...
            cerr << "Attempted to release non-acquired edge "
                 << e->getID() << '\n';
        } else {                            // Ok. We can clean up now
            edgeList.erase(it);
            edgePool.release(e);
        }
    }

    // Low-level single faceVertex disposal
    void releaseFaceVertex(FaceVertexPtr fv) {
        typename FaceVertexPtrList::iterator it = find(faceVertexList.begin(),
                                              faceVertexList.end(), fv);
        if (it == faceVertexList.end()) {         // We never owned this...
            cerr << "Attempted to release non-acquired face-vertex "
                 << fv->getID() << '\n';
        } else {                            // Ok. We can clean up now
            faceVertexList.erase(it);
            faceVertexPool.release(fv);
        }
    }


/*---------------------------------------------------------------------------*
 | Mesh modification functions
 *---------------------------------------------------------------------------*/
public:
    // Create a normal
    index_t createNormal(const Vector &v) {
        index_t index = normalList.size();
        normalList.push_back(v);
        return index;
    }

    // Create a texture coordinates
    index_t createTexCoords(const TexCoords &t) {
        index_t index = texCoordsList.size();
        texCoordsList.push_back(t);
        return index;
    }


    // Create an unattached vertex
    VertexPtr createVertex(const Point &p) {
        VertexPtr v = acquireVertex();
        v->setLocation(p);
        return v;
    }

    // Create a new vertex that splits an existing edge
    VertexPtr createVertex(const Point &p, EdgePtr toSplit) {
        cerr << "WEPolygonMesh::createVertex(edge) >>> NOT IMPLEMENTED <<<\n";
    }

    void deleteVertex(VertexPtr v) {
        cerr << "WEPolygonMesh::deleteVertex >>> NOT IMPLEMENTED <<<\n";
    }


    // Create a new FaceVertex at the specified Vertex
    FaceVertexPtr createFaceVertex(VertexPtr v) {
        FaceVertexPtr fv = acquireFaceVertex();
        fv->setVertex(v);
        return fv;
    }

    void deleteFaceVertex(FaceVertexPtr fv) {
        cerr << "WEPolygonMesh::deleteFaceVertex >>> NOT IMPLEMENTED <<<\n";
    }


    // The createEdge function returns the edge connecting the
    // specifed vertices, creating it if necessary.
    //
    // The Edge object is owned by the mesh and should not be deleted.
    EdgePtr createEdge(VertexPtr startV, VertexPtr endV) {
        EdgePtr edge = NULL;

        // These are the preceding edges in a CCW rotation
        EdgePtr startGapEdge = NULL;
        EdgePtr endGapEdge = NULL;

        // These are the first edges at either vertex
        EdgePtr startFirstEdge = startV->getLinkEdge();
        EdgePtr endFirstEdge = endV->getLinkEdge();

        /* If we have edges at the first vertex, orbit that vertex
         * CCW looking for an existing edge to the end vertex. We're
         * also looking for the gaps between faces, so that if we
         * don't find the a pre-made edge, we know where to create
         * the new one.
         */
        if (startFirstEdge != NULL) {
            EdgePtr currentEdge = startFirstEdge;
            do {
                if (currentEdge->touchesVertex(endV)) {
                    edge = currentEdge;     //...we found it!
                    break;                  // We're done. Let's go.
                } else {                // continue orbiting
                    // See if there's a gap following this edge
                    if (currentEdge->getCCWFace(startV) == NULL)
                        startGapEdge = currentEdge;
                    currentEdge = currentEdge->getCCWEdge(startV);
                }
            } while (currentEdge != startFirstEdge); // more edges!
        }

        if (edge == NULL) { // ... then (rats!) it doesn't exist
            // Well, darn. Since our previous check (around the start
            // vertex) either failed to find the edge, or simply
            // didn't run because there were no edges, there's no
            // point in looking for the edge around the end vertex.
            // However, we do need to look for a place to connect our
            // new edge to the end vertex. So let's get to it.
            if (endFirstEdge != NULL) {
                EdgePtr currentEdge = endFirstEdge;
                do {
                    // See if there's a gap following this edge
                    if (currentEdge->getCCWFace(endV) == NULL)
                        endGapEdge = currentEdge;
                    currentEdge = currentEdge->getCCWEdge(endV);
                } while (currentEdge != endFirstEdge);
            }

            // Now let's make sure there's a place to PUT this thing.
            // It's OK to blow up here, since we haven't actually
            // created anything yet.
            if (startFirstEdge != NULL && startGapEdge == NULL) {
                NonManifoldGeometryException e;
                e << "Attempted to create an edge starting from "
                     "completely enclosed vertex " << startV->getID();
                throw e;
            } else if (endFirstEdge != NULL && endGapEdge == NULL) {
                NonManifoldGeometryException e;
                e << "Attempted to create an edge ending at "
                     "completely enclosed vertex " << endV->getID();
                throw e;
            }

            // OK! Get us a new edge
            edge = acquireEdge();
            edge->setStartVertex(startV);
            edge->setEndVertex(endV);

            // Make sure the vertices have an edge
            if (startFirstEdge == NULL)         startV->setLinkEdge(edge);
            if (endV->getLinkEdge() == NULL)    endV->setLinkEdge(edge);

            // Link our new edge into the gaps we found
            if (startFirstEdge == NULL)
                startV->setLinkEdge(edge);
            else
                startGapEdge->insertAfterCCW(startV, edge);

            if (endFirstEdge == NULL)
                endV->setLinkEdge(edge);
            else
                endGapEdge->insertAfterCCW(endV, edge);
        }
        return edge;
    }

    // XXX This is not robust w/r to faces
    void deleteEdge(EdgePtr e) {
        // Tell everyone to forget about me
        e->extractFrom(e->getStartVertex());
        e->extractFrom(e->getEndVertex());
        
        // Finally, go rejoin the cosmic life force
        releaseEdge(e);
    }


    // The createFace method accepts a list of face-vertices (in CCW order)
    // and creates a face (adding any necessary edges).
    FacePtr createFace(const FaceVertexPtrList &faceVertices) {
        FacePtr face = NULL;    // The face we're gonna make

        // This is where we store all the edges that make up the face, so that
        // we can go back and link in the face (or clean them up if we fail)
        EdgePtrList faceEdges;

        // We want to catch any exceptions that occur, so that we can
        // clean up any orphaned edges and face-vertices before rethrowing it.
        try {
            size_t vertexCount = faceVertices.size();

            if (vertexCount < 3) {
                DegenerateGeometryException e;
                e << "Refusing to create a face with fewer than 3 "
                     "vertices.";
                throw e;
            }

            // Prepare to loop, creating the first edge (maybe)
            VertexPtr v1 = faceVertices[0]->getVertex(),
                      v2 = faceVertices[1]->getVertex();
            EdgePtr currentEdge = createEdge(v1, v2);
            EdgePtr previousEdge = NULL;

            // Now orbit the face, CCW, linking all the edges (we get the
            // first edge on the last iteration)
            for (index_t i = 1; i <= index_t(vertexCount); i++) {
                // Stick the current edge into our list
                faceEdges.push_back(currentEdge);

                // Advance and (potentially) create a new edge
                v1 = faceVertices[i % vertexCount]->getVertex();
                v2 = faceVertices[(i + 1) % vertexCount]->getVertex();
                previousEdge = currentEdge;
                currentEdge = createEdge(v1, v2);

                // If there's a topological inconsistency, we need to snip out
                // part of the mesh and relink
                if (previousEdge->getCWEdge(v1) != currentEdge)
                    relinkEdgesCCW(v1, previousEdge, currentEdge);
            }

            // OK! We made it! Make a face!
            face = acquireFace();
            face->setLinkEdge(faceEdges[0]);
            
            // Link it into the edges...
            for (index_t i = 0; i < index_t(vertexCount); i++)
                faceEdges[i]->setAvailableFace(face);

            // ...and the face-vertices
            for (index_t i = 0; i < index_t(vertexCount); i++) {
                index_t nextI = (i + 1) % vertexCount;
                FaceVertexPtr fv = faceVertices[nextI];
                fv->insertBetween(fv->getVertex(), faceEdges[i], faceEdges[nextI]);
            }

        // In case something goes horribly, horribly wrong...
        } catch (GeometryException &e) {
            // Delete all the face-vertices
            for (index_t i = 0; i < index_t(faceVertices.size()); i++)
                deleteFaceVertex(faceVertices[i]);

            // Delete any edges that don't have family yet
            for (index_t i = 0; i < index_t(faceEdges.size()); i++)
                if (faceEdges[i]->getFaceCount() == 0)
                    deleteEdge(faceEdges[i]);

            // Rethrow for anyone else who's listening
            throw e;
        }

        return face;
    }


    /* This is a bit tricky. Resolve links. Going CCW.
     * Might not be ordered right.
     */
    void relinkEdgesCCW(VertexPtr aroundVertex, EdgePtr e1, EdgePtr e2) {
        EdgePtr fanExtent, e1Neighbor, fanNeighbor, e2Neighbor;
        bool fanIsReversed = false;

//        cerr << "Relinking edges to get E" << e1->getID()
//             << " CCW around V" << aroundVertex->getID()
//             << " w/respect to E" << e2->getID() << '\n'
//             << "e1: " << *e1 << '\n' << "e2: " << *e2 << '\n';

        // First find how far the fan starting at e1 extends
        // (possibly reversing it too)
        FacePtr matchingFace = e2->getCCWFace(aroundVertex);
        if (e1->getCWFace(aroundVertex) == matchingFace) {
            fanExtent = e1->findCCWFanExtent(aroundVertex);
            fanIsReversed = false;

        // Awwww...CRAP! It's backwards! (Stupid modeler...)
        } else if (e1->getCCWFace(aroundVertex) == matchingFace) {
            fanExtent = e1->findCWFanExtent(aroundVertex);
            fanIsReversed = true;
            throw UnsupportedOperationException("Non-CCW faces not supported!");

        // What the @#$%?
        } else {
            // Something has gone horribly wrong, as e1 is not at the
            // perimeter of a fan around the vertex.
            NonManifoldGeometryException e;
            e << "Attempted to reorder edge " << e1->getID() << ", "
                 "which is already hard-linked (i.e. has a face) in "
                 "the CW direction around vertex "
              << aroundVertex->getID() << '\n' << e1;
            throw e;
        }

        if (fanExtent == NULL) {
            // This should actually NEVER happen...
            NonManifoldGeometryException e;
            e << "Attempted to reorder edges belonging to a "
                 "continuous fan around vertex "
              << aroundVertex->getID() << ", containing edge "
              << e1->getID() << '.';
            throw e;
        }
        
//        cerr << "fanExtent: (reverse? " << fanIsReversed << ") " << fanExtent;
//        only needed for non CCW faces
//        if (fanIsReversed)
//            reverseFan(aroundVertex, e1, fanExtent);

        // OK! We're good. Let's extract e1's fan from its neighbors
        e1Neighbor = e1->getCWEdge(aroundVertex);
        fanNeighbor = fanExtent->getCCWEdge(aroundVertex);
        e1Neighbor->setCCWEdge(aroundVertex, fanNeighbor);
        fanNeighbor->setCWEdge(aroundVertex, e1Neighbor);

        // Now put the fan where it belongs
        e2Neighbor = e2->getCCWEdge(aroundVertex);
        e2Neighbor->setCWEdge(aroundVertex, fanExtent);
        fanExtent->setCCWEdge(aroundVertex, e2Neighbor);
        e1->setCWEdge(aroundVertex, e2);
        e2->setCCWEdge(aroundVertex, e1);
    }
    

    /* Run through the fan centered at a vertex, between the two
     * edges and switch the CW/CCW orientation of edges. This
     * operation is never necessary if the vertices for a face are
     * always specified in a consistent ordering. If, however, some
     * faces are specified CCW, and others are specified CW, this
     * discrepancy will eventually cause a topological conflict, and
     * some parts of the mesh will need to be reversed.
     */
    void reverseFan(VertexPtr aroundVertex,
                    EdgePtr ccwExtent, EdgePtr cwExtent) {
        EdgePtr currentEdge = ccwExtent, nextEdge;
        do {
            // Swap the CW & CCW edges
            nextEdge = currentEdge->getCWEdge(aroundVertex);
            currentEdge->setCWEdge(aroundVertex,
                    currentEdge->getCCWEdge(aroundVertex));
            currentEdge->setCCWEdge(aroundVertex, nextEdge);

            currentEdge = nextEdge; // Go to the next one
        } while (currentEdge != cwExtent);
    }
};

#endif
