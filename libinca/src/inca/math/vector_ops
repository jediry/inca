/* -*- C++ -*-
 *
 * File: vector_operations
 *
 * Author: Ryan L. Saunders
 *
 * Copyright 2004, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 *      This file declares the various operations that work on vector-type
 *      objects (including Vector, Point, Matrix, etc.). They are defined
 *      here rather than in the files implementing the various vector templates
 *      because some of the operations operate across types (e.g., a Matrix
 *      multiplied by a Vector), so there isn't a natural home for them.
 *      For the sake of consistency, all operations but those that MUST be
 *      implemented within the template classes are here instead.
 *
 *      Because there is so much commonality between the implementations
 *      of the operators and functions defined herein, and to enhance
 *      readability of this file, extensive use of the C preprocessor has been
 *      made. This has allowed many functions to be implemented in a single
 *      line, significantly cutting down on the size of this file.
 *
 *          S               scalar
 *          S_ARG           scalar function argument
 *          P(0)            Point of dimension D
 *          V(0)            Vector of dimension D
 *          Q               Quaternion
 *          M(0,1,0)    Matrix of dimensions D1 x D2, with storage order O
 *
 * Doc me!! XXX
 *      How the macros work (sob!)
 */

#ifndef INCA_MATH_V_OPERATIONS
#define INCA_MATH_V_OPERATIONS

// Import Boost preprocessor metaprogramming library
#include <boost/preprocessor/punctuation/comma_if.hpp>
#include <boost/mpl/minus.hpp>


// Import Inca's template metaprogramming utilities
#include <inca/util/metaprogramming>

// Import the definitions of the various vector-type template classes
#include "vector_types"

// Import the scalar ops (some of which will be reimplemented for vectors)
#include "scalar_ops"


// These preprocessor macros are only used locally within this file, and
// help make all the template crap readable. They should all be #undef'd at
// the end of this file.
#define TEMPLATE(DIMS, MTXS)                                                \
    template <typename scalar                                               \
              BOOST_PP_COMMA_IF(DIMS) BOOST_PP_ENUM_PARAMS(DIMS, size_t dim)\
              BOOST_PP_COMMA_IF(MTXS) BOOST_PP_ENUM_PARAMS(MTXS, bool order)>

#define D       dim0    // Useful alias for 1D containers
#define D1      dim0    // These are useful for
#define D2      dim1    // referring to Matrix dimensions
#define D3      dim2
#define O1      order0  // These are useful for referring to Matrix
#define O2      order1  // storage orders (row-major, col-major)


#define S           scalar
#define S_ARG       typename scalar_traits<scalar>::arg_type
#define L(D)        ScalarList<scalar, dim ## D>// These macros are all
#define P(D)        Point<scalar,  dim ## D>    // convenient shorthand for
#define V(D)        Vector<scalar, dim ## D>    // our templated list-type
#define Q           Quaternion<scalar>          // thingies
#define M(D1,D2,O)  Matrix<scalar, dim ## D1, dim ## D2, order ## O>

#define POINT(D)    Point<scalar, D >
#define VECTOR(D)   Vector<scalar, D >

#define OSTREAM_OP_L(RHS)                                                   \
    ostream & operator<<(ostream &o, const RHS & rhs) {                     \
        return o << string(rhs);                                            \
    }

#define L_ASSIGN_L(LHS, OP, RHS)                                            \
    LHS & operator OP (LHS & lhs, const RHS & rhs) {                        \
        for (index_t i = 0; i < lhs.size; i++)                              \
            lhs[i] OP rhs[i];                                               \
        return lhs;                                                         \
    }

#define L_ASSIGN_S(LHS, OP, RHS_DUMMY)                                      \
    LHS & operator OP (LHS & lhs, S_ARG rhs) {                              \
        for (index_t i = 0; i < lhs.size; i++)                              \
            lhs[i] OP rhs;                                                  \
        return lhs;                                                         \
    }

#define OP_L(RET, OP, RHS)                                                  \
    RET operator OP (const RHS & rhs) {                                     \
        RET result;                                                         \
        for (index_t i = 0; i < rhs.size; i++)                              \
            result[i] = OP rhs[i];                                          \
        return result;                                                      \
    }

#define L_OP_L(RET, LHS, OP, RHS)                                           \
    RET operator OP (const LHS & lhs, const RHS & rhs) {                    \
        RET result;                                                         \
        for (index_t i = 0; i < lhs.size; i++)                              \
            result[i] = lhs[i] OP rhs[i];                                   \
        return result;                                                      \
    }

#define L_OP_S(RET, LHS, OP, RHS_DUMMY)                                     \
    RET operator OP (const LHS & lhs, S_ARG rhs) {                          \
        RET result;                                                         \
        for (index_t i = 0; i < lhs.size; i++)                              \
            result[i] = lhs[i] OP rhs;                                      \
        return result;                                                      \
    }

#define S_OP_L(RET, LHS_DUMMY, OP, RHS)                                     \
    RET operator OP (S_ARG lhs, const RHS & rhs) {                          \
        RET result;                                                         \
        for (index_t i = 0; i < rhs.size; i++)                              \
            result[i] = lhs OP rhs[i];                                      \
        return result;                                                      \
    }

#define L_EQ_L(LHS, RHS)                                                    \
    bool operator == (const LHS & lhs, const RHS & rhs) {                   \
        for (index_t i = 0; i < lhs.size; i++)                              \
            if (! effectivelyEqual(lhs[i], rhs[i]))                         \
                return false;                                               \
        return true;                                                        \
    }

#define L_NE_L(LHS, RHS)                                                    \
    bool operator != (const LHS & lhs, const RHS & rhs) {                   \
        return ! (lhs == rhs);                                              \
    }


// This is part of the Inca math library
namespace inca {
    namespace math {
    /*-----------------------------------------------------------------------*
     | iostream interface operators
     *-----------------------------------------------------------------------*/
        // std::ostream "<<" operators
        TEMPLATE(1, 0) OSTREAM_OP_L( P(0) );        // o << P
        TEMPLATE(1, 0) OSTREAM_OP_L( V(0) );        // o << V
        TEMPLATE(0, 0) OSTREAM_OP_L( Q );           // o << Q
        TEMPLATE(2, 1) OSTREAM_OP_L( M(0,1,0) );    // o << M


    /*-----------------------------------------------------------------------*
     | Comparison operators
     *-----------------------------------------------------------------------*/
        TEMPLATE(1, 0) L_EQ_L( P(0), P(0) );                    // P == P ?
        TEMPLATE(1, 0) L_NE_L( P(0), P(0) );                    // P != P ?
        TEMPLATE(1, 0) L_EQ_L( V(0), V(0) );                    // V == V ?
        TEMPLATE(1, 0) L_NE_L( V(0), V(0) );                    // V != V ?
        TEMPLATE(0, 0) L_EQ_L( Q, Q );                          // Q == Q ?
        TEMPLATE(0, 0) L_NE_L( Q, Q );                          // Q != Q ?
        TEMPLATE(2, 1) L_EQ_L( M(0,1,0), M(0,1,0) );            // M == M ?
        TEMPLATE(2, 1) L_NE_L( M(0,1,0), M(0,1,0) );            // M != M ?


    /*-----------------------------------------------------------------------*
     | Extended assignment operators
     *-----------------------------------------------------------------------*/
        // Assignment operators for Point
        TEMPLATE(1,0) L_ASSIGN_L( P(0), +=, P(0) );             // P += P
        TEMPLATE(1,0) L_ASSIGN_L( P(0), -=, P(0) );             // P -= P
        TEMPLATE(1,0) L_ASSIGN_L( P(0), +=, V(0) );             // P += V
        TEMPLATE(1,0) L_ASSIGN_L( P(0), -=, V(0) );             // P -= V
        TEMPLATE(1,0) L_ASSIGN_S( P(0), *=, S    );             // P *= S
        TEMPLATE(1,0) L_ASSIGN_S( P(0), /=, S    );             // P /= S

        // Assignment operators for V(0)
        TEMPLATE(1,0) L_ASSIGN_L( V(0), +=, P(0) );             // V += P
        TEMPLATE(1,0) L_ASSIGN_L( V(0), -=, P(0) );             // V -= P
        TEMPLATE(1,0) L_ASSIGN_L( V(0), +=, V(0) );             // V += V
        TEMPLATE(1,0) L_ASSIGN_L( V(0), -=, V(0) );             // V -= V
        TEMPLATE(1,0) L_ASSIGN_S( V(0), *=, S    );             // V *= S
        TEMPLATE(1,0) L_ASSIGN_S( V(0), /=, S    );             // V /= S

        // Assignment operators for Quaternion

        // Assignment operators for M(0,1,0)
        TEMPLATE(2,1) L_ASSIGN_L( M(0,1,0), +=, M(0,1,0) );     // M += M
        TEMPLATE(2,1) L_ASSIGN_L( M(0,1,0), -=, M(0,1,0) );     // M -= M
        TEMPLATE(2,1) L_ASSIGN_S( M(0,1,0), *=, S        );     // M *= S
        TEMPLATE(2,1) L_ASSIGN_S( M(0,1,0), /=, S        );     // M /= S


    /*-----------------------------------------------------------------------*
     | Arithmetic operators
     *-----------------------------------------------------------------------*/
        // Unary operators for element-wise negation of list types
        TEMPLATE(1,0) OP_L( P(0),     -, P(0) );                // P = -P
        TEMPLATE(1,0) OP_L( V(0),     -, V(0) );                // V = -V
        TEMPLATE(0,0) OP_L( Q,        -, Q );                   // Q = -Q
        TEMPLATE(2,1) OP_L( M(0,1,0), -, M(0,1,0) );            // M = -M

        // Binary operators for element-wise operations between list types
        TEMPLATE(1,0) L_OP_L( P(0), P(0), +, P(0) );            // P = P + P
        TEMPLATE(1,0) L_OP_L( V(0), P(0), -, P(0) );            // V = P - P
        TEMPLATE(1,0) L_OP_L( P(0), P(0), *, P(0) );            // P = P * P
        TEMPLATE(1,0) L_OP_L( P(0), P(0), /, P(0) );            // P = P / P
        TEMPLATE(1,0) L_OP_L( P(0), P(0), +, V(0) );            // P = P + V
        TEMPLATE(1,0) L_OP_L( P(0), P(0), -, V(0) );            // P = P - V
        TEMPLATE(1,0) L_OP_L( V(0), V(0), +, V(0) );            // V = V + V
        TEMPLATE(1,0) L_OP_L( V(0), V(0), -, V(0) );            // V = V - V
        TEMPLATE(1,0) L_OP_L( V(0), V(0), *, V(0) );            // V = V * V
        TEMPLATE(1,0) L_OP_L( V(0), V(0), /, V(0) );            // V = V / V
        TEMPLATE(1,0) L_OP_L( P(0), V(0), +, P(0) );            // P = V + P
        TEMPLATE(1,0) L_OP_L( P(0), V(0), -, P(0) );            // P = V - P
        TEMPLATE(0,0) L_OP_L( Q, Q, +, Q );                     // Q = Q + Q
        TEMPLATE(0,0) L_OP_L( Q, Q, -, Q );                     // Q = Q - Q

        TEMPLATE(2,1) L_OP_L( M(0,1,0), M(0,1,0), +, M(0,1,0) );// M = M + M
        TEMPLATE(2,1) L_OP_L( M(0,1,0), M(0,1,0), -, M(0,1,0) );// M = M - M
//       TEMPLATE(2,1) L_OP_L( M(0,1,0), M(0,1,0), *, M(0,1,0) );    // M = M * M
//       TEMPLATE(2,1) L_OP_L( M(0,1,0), M(0,1,0), /, M(0,1,0) );    // M = M / M

        // Binary operators for scaling list types
        TEMPLATE(1,0) L_OP_S( P(0),     P(0),     *, S        );// P = P * S
        TEMPLATE(1,0) L_OP_S( P(0),     P(0),     /, S        );// P = P / S
        TEMPLATE(1,0) S_OP_L( P(0),     S,        *, P(0)     );// P = S * P
        TEMPLATE(1,0) S_OP_L( P(0),     S,        /, P(0)     );// P = S / P
        TEMPLATE(1,0) L_OP_S( V(0),     V(0),     *, S        );// V = V * S
        TEMPLATE(1,0) L_OP_S( V(0),     V(0),     /, S        );// V = V / S
        TEMPLATE(1,0) S_OP_L( V(0),     S,        *, V(0)     );// V = S * V
        TEMPLATE(1,0) S_OP_L( V(0),     S,        /, V(0)     );// V = S / V
        TEMPLATE(0,0) L_OP_S( Q,        Q,        *, S        );// Q = Q * S
        TEMPLATE(0,0) L_OP_S( Q,        Q,        /, S        );// Q = Q / S
        TEMPLATE(0,0) S_OP_L( Q,        S,        *, Q        );// Q = S * Q
        TEMPLATE(0,0) S_OP_L( Q,        S,        /, Q        );// Q = S / Q
        TEMPLATE(2,1) L_OP_S( M(0,1,0), M(0,1,0), *, S        );// M = M * S
        TEMPLATE(2,1) L_OP_S( M(0,1,0), M(0,1,0), /, S        );// M = M / S
        TEMPLATE(2,1) S_OP_L( M(0,1,0), S,        *, M(0,1,0) );// M = S * M
        TEMPLATE(2,1) S_OP_L( M(0,1,0), S,        /, M(0,1,0) );// M = S / M


    /*-----------------------------------------------------------------------*
     | ScalarList operations -- these operate identically for all ScalarList
     | subtypes
     *-----------------------------------------------------------------------*/
        /**
         * Calculates the scalar sum of the items in \a lst.
         * \param   lst a ScalarList or derived type
         * \returns the value \code lst[0] + lst[1] + ... + lst[n-1] \endcode
         */
        TEMPLATE(1,0)
        S sum(const L(0) & lst) {
            S result = lst[0];
            for (index_t i = 1; i < lst.size; i++)
                result += lst[i];
            return result;
        }

        /**
         * Calculates the scalar product of the items in \a lst.
         * \param   lst a ScalarList or derived type
         * \returns the value \code lst[0] * lst[1] * ... * lst[n-1] \endcode
         */
        TEMPLATE(1,0)
        S product(const L(0) & lst) {
            S result = lst[0];
            for (index_t i = 1; i < lst.size; i++)
                result *= lst[i];
            return result;
        }

        /**
         * Finds the smallest (i.e., most negative) value in \a lst.
         * \param   lst a ScalarList or derived type
         * \returns the value \code min(lst[0], lst[1], ... ,lst[n-1]) \endcode
         */
        TEMPLATE(1,0)
        S min(const L(0) & lst) {
            S result = lst[0];
            for (index_t i = 1; i < lst.size; i++)
                if (lst[i] < result)
                    result = lst[i];
            return result;
        }

        /**
         * Finds the largest (i.e., most positive) value in \a lst.
         * \param   lst a ScalarList or derived type
         * \returns the value \code max(lst[0], lst[1], ... ,lst[n-1]) \endcode
         */
        TEMPLATE(1,0)
        S max(const L(0) & lst) {
            S result = lst[0];
            for (index_t i = 1; i < lst.size; i++)
                if (lst[i] > result)
                    result = lst[i];
            return result;
        }

        // Dot product
        TEMPLATE(1,0)
        S dot(const L(0) &l1, const L(0) &l2) {
            S result = 0;
            for (index_t i = 0; i < l1.size; i++)
                result += l1[i] * l2[i];
            return result;
        }

//        LIST_ELEMENTWISE_FUNCTION_1_ARG(abs);
//        LIST_ELEMENTWISE_FUNCTION_1_ARG(floor);
//        LIST_ELEMENTWISE_FUNCTION_1_ARG(ceiling);
//        LIST_ELEMENTWISE_FUNCTION_1_ARG(round);

        //LIST_ELEMENTWISE_FUNCTION(square);
//        LIST_ELEMENTWISE_FUNCTION_1_ARG(sqrt);

//        LIST_ELEMENTWISE_FUNCTION_2_ARG(pow);


    /*-----------------------------------------------------------------------*
     | Point operations
     *-----------------------------------------------------------------------*/
        // Cartesian distance between two points (L-2)
        TEMPLATE(1,0)
        S distance(const P(0) &p0, const P(0) &p1) {
            S result = 0;
            for (index_t i = 0; i < p0.size; i++) { // Accumulate the squares
                S diff = p1[i] - p0[i];             // of differences along
                result += diff * diff;              // each axis
            }
            return sqrt(result);
        }


    /*-----------------------------------------------------------------------*
     | Vector operations
     *-----------------------------------------------------------------------*/
        // Cartesian Distance Metric (L-2)
        TEMPLATE(1,0)
        S magnitude(const V(0) &v) {
            S result = 0;
            for (index_t i = 0; i < v.size; i++)
                result += v[i] * v[i];
            return sqrt(result);
        }

        // Interior angle between vectors. The result will lie within [0, pi].
        TEMPLATE(1,0)
        S angle(const V(0) &v1, const V(0) &v2) {
            S cosine = dot(v1, v2) / magnitude(v1) / magnitude(v2);
            return arccos(cosine);
        }

        // Signed angle between two vectors, with reference to an "up" vector.
        // The result will lie within the range [-pi, pi]
        // (all vectors should be pre-normalized)
        TEMPLATE(1,0)
        S signedAngle(const V(0) &v1, const V(0) &v2, const V(0) &up) {
            S cosine = dot(v1, v2),
              sine   = dot((v1 % v2), up);
            return arctan(sine, cosine);
        }
        // Special case for 2D vectors (doesn't need an 'up' vector).
        TEMPLATE(0,0)
        S signedAngle(const VECTOR(2) &v1, const VECTOR(2) &v2) {
            S alpha = arctan(v1[0], v1[1]),
              beta  = arctan(v2[0], v2[1]);
            return beta - alpha;
        }

        // Canonical angle between two vectors. The result will lie within
        // the range [0, 2pi).
        TEMPLATE(1,0)
        S canonicalAngle(const V(0) &v1, const V(0) &v2, const V(0) &up) {
            S alpha = signedAngle(v1, v2, up);
            return (alpha >= 0) ? alpha : 2 * PI<S>() + alpha;
        }
        // Special case for 2D vectors (doesn't need an 'up' vector).
        TEMPLATE(0,0)
        S canonicalAngle(const VECTOR(2) &v1, const VECTOR(2) &v2) {
            S alpha = signedAngle(v1, v2);
            return (alpha >= 0) ? alpha : 2 * PI<S>() + alpha;
        }

//        // Dot product
//        TEMPLATE(1,0)
//        S dot(const V(0) &v1, const V(0) &v2) {
//            S result = 0;
//            for (index_t i = 0; i < v1.size; i++)
//                result += v1[i] * v2[i];
//            return result;
//        }

        // Cross product
        TEMPLATE(1,0)
        V(0) operator%(const V(0) &v1, const V(0) &v2) {
            V(0) result;
            if (D >= 3) {     // Only defined for dim >= 3
                for (index_t i = 0; i < D; i++)
                    result[i] = v1[(i + 1) % D] * v2[(i + 2) % D]
                              - v1[(i + 2) % D] * v2[(i + 1) % D];
            }
            return result;
        }

        // Normalized vector
        TEMPLATE(1,0)
        V(0) normalize(const V(0) &v) {
            return v / magnitude(v);
        }

//        // Vector normalization
//        void normalize() {
//            scalar_t length = magnitude(*this);
//            if (length != 0)
//                elements /= length;
//        }

        // Normal-vector reflection
        TEMPLATE(1,0)
        V(0) reflect(const V(0) &v, const V(0) &normal) {
            V(0) n = normalize(normal);
            return 2 * n * dot(v, n) - v;
        }

        // Project a vector into a plane (represented by its normal,
        // which must be normalized)
        TEMPLATE(1,0)
        V(0) project(const V(0) &v, const V(0) &n) {
            return v - n * dot(n, v);
        }

        // Vector between two points, but perpendicular to another
        // (normalized) vector
        TEMPLATE(1,0)
        V(0) project(const P(0) &p1, const P(0) &p2, const V(0) &n) {
            V(0) tween = p1 - p2;
            return project(tween, n);
        }


    /*-----------------------------------------------------------------------*
     | Quaternion operations
     *-----------------------------------------------------------------------*/
        // Cartesian Distance Metric (L-2)
        TEMPLATE(0,0)
        S magnitude(const Q &q) {
            S result = 0;
            for (index_t i = 0; i < 4; i++)
                result += q[i] * q[i];
            return sqrt(result);
        }

        // The rotation angle (in radians) around the natural axis
        TEMPLATE(0,0)
        S angle(const Q &q) {
            return S(2.0) * arccos(q[0] / magnitude(q));
        }

        // The normalized natural axis of the quaternion
        TEMPLATE(0,0)
        VECTOR(3) axis(const Q &q) {
            return normalize(VECTOR(3)(q[1], q[2], q[3]));
        }

        // Conjugate of a quaternion
        TEMPLATE(0,0)
        Q conjugate(const Q &q) {
            return Q(q[0], -q[1], -q[2], -q[3]);
        }

        // Inverse of a quaternion
        TEMPLATE(0,0)
        Q inverse(const Q &q) {
            // Find the square of the magnitude of 'q'
            S ms = 0.0;
            for (index_t i = 0; i < 4; i++)
                ms += q[i] * q[i];

            // Find the components of the inverse
            return Q(q[0] / ms, -q[1] / ms,
                             -q[2] / ms, -q[3] / ms);
        }

        // Normalized quaternion
        TEMPLATE(0,0)
        Q normalize(const Q &q) {
            S length = magnitude(q);
            if (length != 0)    return q / length;
            else                return q;
        }

        // Quaternion multiplication
        TEMPLATE(0,0)
        Q operator%(const Q &q1, const Q &q2) {
            S e0, e1, e2, e3;
            e0 = q1[0]*q2[0] - q1[1]*q2[1] - q1[2]*q2[2] - q1[3]*q2[3];
            e1 = q1[0]*q2[1] + q1[1]*q2[0] + q1[2]*q2[3] - q1[3]*q2[2];
            e2 = q1[0]*q2[2] + q1[2]*q2[0] + q1[3]*q2[1] - q1[1]*q2[3];
            e3 = q1[0]*q2[3] + q1[3]*q2[0] + q1[1]*q2[2] - q1[2]*q2[1];
            return Q(e0, e1, e2, e3);
        }


//        // Interior angle between quaternions
//        template <class Scalar>
//        typename Scalar::type angle(const Quaternion<Scalar> &q1,
//                                    const Quaternion<Scalar> &q2) {
//            XXXXXXX
//            typename Scalar::type cosine
//                = q1 * q2 / magnitude(q1) / magnitude(q2);
//            return Scalar::arccos(cosine);
//        }

//        // Signed angle between vectors, with reference to an "up"
//        // (all vectors should be pre-normalized)
//        template <class Scalar>
//        typename Scalar::type angle(Quaternion<Scalar> q1,
//                                    Quaternion<Scalar> q2,
//                                    Quaternion<Scalar> up) {
//            XXXXXXXX
//            typename Scalar::type cosine = q1 * q2,
//                                  sine = (q1 % q2) * up;
//
 //           return Scalar::arctan(sine, cosine);
//        }


    /*************************************************************************
     * Ray operations
     *************************************************************************/
#if 0
        // Normalized ray
        TEMPLATE
        LIST(Ray) normalize(const LIST(Ray) &r) {
            const LIST(Point) &p = r.point();
            const LIST(Vector) &v = r.vector();
            return LIST(Ray)(p, v / magnitude(v));
        }

        // Normal-vector reflection
        TEMPLATE
        LIST(Ray) reflect(const LIST(Ray) &r,
                              const LIST(Vector) &n) {
            return LIST(Ray)(r.point(), reflect(r.vector(), n));
        }

    /*************************************************************************
     * Matrix operations
     *************************************************************************/
        // Calculate a submatrix by eliminating a row and a column
        template <typename scalar, size_t rows, size_t cols>
        Matrix<scalar, rows - 1, cols - 1>
        sub(const Matrix<scalar, rows, cols> &m, index_t er, index_t ec) {
            Matrix<scalar, rows - 1, cols - 1> result;
            for (index_t c = 0; c < ec; c++)
                for (index_t r = 0; r < er; r++)
                    result(r, c) = m(r, c);
            for (index_t c = 0; c < ec; c++)
                for (index_t r = er; r < rows - 1; r++)
                    result(r, c) = m(r + 1, c);
            for (index_t c = ec; c < cols - 1; c++)
                for (index_t r = 0; r < er; r++)
                    result(r, c) = m(r, c + 1);
            for (index_t c = ec; c < cols - 1; c++)
                for (index_t r = er; r < rows - 1; r++)
                    result(r, c) = m(r + 1, c + 1);
            return result;
        }

        // Calculate Matrix determinant (square matrices only)
        template <class Scalar, size_t dim>
        typename Scalar::type det(const Matrix<Scalar, dim, dim> &m) {
            typename Scalar::type result = 0;
            for (index_t i = 0; i < dim; i++)
                if (i % 2 == 0)
                    result += m(i, 0) * det(sub(m, i, 0));
                else
                    result -= m(i, 0) * det(sub(m, i, 0));
            return result;
        }

        // Determinant of 1x1 Matrix is trivial
        template <class Scalar>
        typename Scalar::type det(const Matrix<Scalar, 1, 1> &m) {
            return m(0, 0);
        }

        // Matrix inverse (square matrices only)
        template <class Scalar, size_t dim>
        Matrix<Scalar, dim, dim> inverse(const Matrix<Scalar, dim, dim> &m) {
            typename Scalar::type detM = det(m);
            Matrix<Scalar, dim, dim> inv;
            bool negative;
            for (index_t r = 0; r < dim; r++) {
                negative = (r % 2 != 0);
                for (index_t c = 0; c < dim; c++) {
                    if (negative)
                        inv(c, r) = -det(m.sub(r, c)) / detM;
                    else
                        inv(c, r) = det(m.sub(r, c)) / detM;
                    negative = !negative;
                }
            }
            return inv;
        }

        // Inverse of 1x1 Matrix is trivial
        template <class Scalar>
        Matrix<Scalar, 1, 1> inverse(const Matrix<Scalar, 1, 1> &m) {
            return Matrix<Scalar, 1, 1>(1.0 / m(0, 0));
        }

        // Matrix transpose
        template <class Scalar, size_t rows, size_t cols>
        Matrix<Scalar, cols, rows>
        transpose(const Matrix<Scalar, rows, cols> &m) {
            Matrix<Scalar, cols, rows> result;
            for (index_t r = 0; r < rows; r++)
                for (index_t c = 0; c < cols; c++)
                    result(c, r) = m(r, c);
            return result;
        }
#endif
        // Matrix Multiplication
        //      This function implements a general matrix multiplication.
        //      Let the dimensions of this matrix be MxN, where M and N are the
        //      row and column dimensions, respectively. The other operand is an
        //      NxP matrix. The resulting matrix is MxP.
        //
        //      If the two matrices have different storage orders, the resulting
        //      matrix will have the storage order of the LHS matrix.
        TEMPLATE(3,1)
        M(0,2,0) operator%(const M(0,1,0) &m1, const M(1,2,0) &m2) {
            M(0,2,0) result;
            for (index_t d1 = 0; d1 < D1; d1++)
                for (index_t d3 = 0; d3 < D3; d3++) {
                    result.rowCol(d1, d3) = 0;
                    for (index_t d2 = 0; d2 < D2; d2++)
                        result.rowCol(d1, d3) += m1.rowCol(d1, d2)
                                               * m2.rowCol(d2, d3);
                }
            return result;
        }

        // Right multiplication of a Matrix by a point (column vector with
        // implicit homogeneous coordinate w == 1)
//        TEMPLATE(2, 1)
//        POINT( M(0,1,0)::cols-1 )
//        operator%(const M(0,1,0) &m, const POINT( M(0,1,0)::cols-1 ) &p) {
//            POINT( M(0,1,0)::cols-1 ) result;
        TEMPLATE(2, 1)
        POINT( ( boost::mpl::minus<boost::mpl::integral_c<unsigned int, dim1>, boost::mpl::integral_c<unsigned int, 1> >::type::value ) )
        operator%(const M(0,1,0) &m, const POINT( ( boost::mpl::minus<boost::mpl::integral_c<unsigned int, dim1>, boost::mpl::integral_c<unsigned int, 1> >::type::value ) ) &p) {
            POINT( ( boost::mpl::minus<boost::mpl::integral_c<unsigned int, dim1>, boost::mpl::integral_c<unsigned int, 1> >::type::value ) ) result;

            // Calculate the normal multiplication of matrix by column vector
            for (index_t r = 0; r < m.rows - 1; r++) {
                result[r] = m.rowCol(r, m.cols - 1);
                for (index_t c = 0; c < m.cols - 1; c++)
                    result[r] += m.rowCol(r, c) * p[c];
            }

            // Figure out the value of 'w', the homogeneous coordinate (which
            // is implicitly '1' in the input point).
            S w = m.rowCol(m.rows - 1, m.cols - 1); // * S(1)
            for (index_t c = 0; c < m.cols - 1; c++)
                w += m.rowCol(m.rows - 1, c) * p[c];

            // Divide through by 'w' to make the output point's homogeneous
            // coordinate '1' (so we don't have to explicitly represent it).
            if (w != S(1))
                for (index_t r = 0; r < m.rows - 1; r++)
                    result[r] /= w;
            return result;
        }
    };
};


// Clean up the preprocessor's namespace
#undef TEMPLATE
#undef D
#undef D1
#undef D2
#undef O1
#undef O2

#undef S
#undef S_ARG
#undef P
#undef V
#undef Q
#undef M
#undef L

#undef POINT
#undef VECTOR

#undef OSTREAM_OP_L
#undef L_ASSIGN_S
#undef L_ASSIGN_L
#undef OP_L
#undef L_OP_L
#undef L_OP_S
#undef S_OP_L
#undef L_EQ_L
#undef L_NE_L

#endif
