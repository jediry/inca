/* -*- C++ -*-
 *
 * File: Cube
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2002, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 */

#ifndef INCA_MATH_SOLID_CUBE
#define INCA_MATH_SOLID_CUBE


// Import superclass definition
#include "../Shape"


// This is part of the Inca geometry library
namespace Inca {
    namespace Geometry {
        // Forward declaration
        template <class Scalar, unsigned int dim> class Cube;
    };
};


template <class Scalar, unsigned int dim>
class Inca::Geometry::Cube : public Shape<Scalar, dim> {
private:
    // Convenience typedefs
    typedef Cube<Scalar, dim>                   ThisType;
    typedef Shape<Scalar, dim>                  Superclass;

public:
    // What dimensional space are we working in?
    const static unsigned int dimension = dim;

    // Template typedefs
    typedef typename Superclass::scalar_t       scalar_t;
    typedef typename Superclass::scalar_arg_t   scalar_arg_t;
    typedef typename Superclass::Point          Point;
    typedef typename Superclass::Vector         Vector;
    typedef typename Superclass::Ray            Ray;

protected:
    // Lengths in each direction
    scalar_t size[dimension];


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:


/*---------------------------------------------------------------------------*
 | Accessor functions
 *---------------------------------------------------------------------------*/
public:
    scalar_t getXSize() const { return size[0]; }
    void setXSize(scalar_arg_t x) { size[0] = x; }
    scalar_t getYSize() const { return size[1]; }
    void setYSize(scalar_arg_t y) { size[1] = y; }
    scalar_t getZSize() const { return size[2]; }
    void setZSize(scalar_arg_t z) { size[2] = z; }
    
    scalar_t calculateDistance(const Ray &along) const {
        scalar_t minT = POS_INF;
        const Point &p = along.point();
        const Vector &v = along.vector();
        for (unsigned int i = 0; i < dimension; i++) {
            if (v[i] == 0)          // No delta in this direction. Skip.
                continue;

            // Find the shortest positive distance to a plane in this dimension
            scalar_t t1 = (size[i] / 2 - p[i]) / v[i],    // upper plane
                   t2 = (- size[i] / 2 - p[i]) / v[i];  // lower plane
            scalar_t t = min(t1, t2);

            // If this could be a "closest intersection", look closer
            if (t < minT) {

                // See if the other dimensions are within the cube's bounds
                Point hit = along.pointAt(t);
                bool onCube = true;
                for (unsigned int j = 0; j < dimension; j++)
                    if (j != i && abs(hit[j]) > size[j] / 2)
                        onCube = false;
                
                if (onCube)     // Yay!
                    minT = t;
            }
        }
        return minT;    // Here's your answer
    }

    // The normal is defined as normal to the nearest plane
    Vector calculateNormal(const Ray &at) const {
        const Point &p = at.point();
        unsigned int minDimension = 0;
        scalar_t minDelta = abs(abs(p[0]) - size[0]  / 2);
        for (unsigned int i = 1; i < dimension; i++) {
            scalar_t delta = abs(abs(p[i]) - size[i]  / 2);
            if (delta < minDelta) {
                minDelta = delta;
                minDimension = i;
            }
        }

        // Construct the normal vector
        Vector result;
        if (p[minDimension] > 0)    result[minDimension] = 1;
        else                        result[minDimension] = -1;

        return result;
    }
};

#endif
