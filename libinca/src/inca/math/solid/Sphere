/* -*- C++ -*-
 *
 * File: Sphere
 * 
 * Author: Ryan L. Saunders
 *
 * Copyright 2002, Ryan L. Saunders. All rights reserved.
 *
 * Description:
 */

#ifndef INCA_MATH_SOLID_SPHERE
#define INCA_MATH_SOLID_SPHERE

// This is part of the Inca math library
namespace inca {
    namespace math {
        // Forward declarations
        template <typename _scalar_t, size_t dim> class Sphere;
    };
};


template <typename _scalar_t, size_t dim>
class inca::math::Sphere {
public:
    // What dimensionality are we working with?
    static const size_t dimensionality = dim;

    // Type definitions
    INCA_MATH_SCALAR_TYPES(_scalar_t, IS_WITHIN_TEMPLATE);
    INCA_MATH_LINALG_TYPES(scalar_t, dim);


/*---------------------------------------------------------------------------*
 | Constructors
 *---------------------------------------------------------------------------*/
public:
    Sphere() : _radius(1) { }


/*---------------------------------------------------------------------------*
 | Accessor functions
 *---------------------------------------------------------------------------*/
public:
    scalar_t radius() const { return _radius; }
    void setRadius(scalar_arg_t r) { _radius = r; }

#if 0
    scalar_t calculateDistance(const Ray &along) const {
        Vector p_to_center = Point() - along.point();
        scalar_t b = along.vector() * p_to_center,
               delta = b * b + radius * radius - (p_to_center * p_to_center);

        if (delta < 0)          //...no intersection
            return POS_INF;
        else if (delta == 0)    //...one hit
            return b;
        else {                  //...two hits
            scalar_t sqrt_delta = sqrt(delta);
            scalar_t intersect1 = b - sqrt_delta,
                   intersect2 = b + sqrt_delta;
            if (intersect1 > 0)
                return intersect1;
            else if (intersect2 > 0)
                return intersect2;
            else
                return POS_INF;
        }
    }

    Vector calculateNormal(const Ray &at) const {
        Vector result = (at.point() - Point()) / radius;
        return result;
    }
#endif

protected:
    scalar_t _radius;   // The radius of the sphere
};

#endif
